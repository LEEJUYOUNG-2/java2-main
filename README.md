# 이주영 202230140

## 5월 29일
### 컨테이너와 컴포넌트
#### 컨테이너
* 다른 컴포넌트를 포함할 수 있는 GUI 컴포넌트 : java.awt.Container를 상속받음
* 다른 컨테이너에 포함될 수 있음
* AWT 컨테이너 : Panel, Frame, Applet, Dialog, Window
* Swing컨테이너 : JPanel JFrame, JApplet, JDialog, JWindow

#### 컴포넌트
* 컨테이너에 포함되어야 화면에 출력될 수 있는 GUI 객체
* 다른 컴포넌트를 포함할 수 없는 순수 컴포넌트
* 모든 GUI 컴포넌트가 상속받는 클래스 : java.awt.Component
* 스윙 컴포넌트가 상속받는 클래스 : javax.swing.Jcomponent

### 최상위 컨테이너
* 다른 컨테이너에 포함되지 않고도 화면에 출력되며, 독립적으로 존재 가능한 컨테이너
* 스스로 화면에 자신을 출력하는 컨테이너 : JFrane, JDialog, JApplet
 #### Swing GUI 프로그램 만들기
 
### 스윙 GUI 프로그램을 만드는 과정
* 스윙 프래임 만들기
* main() 메소드 작성
* 스윙 프레임에 스윙 컴포넌트 붙이기

### 스윙 프로그램 작성에 필요한 import문
```
import java.awt.*; //그래픽 처리를 위한 클래스들 경로명
import java.awt.event.*; // AWT 이벤트 사용을 위한 경로명
import javax.swing.*; // 스윙 컴포넌트 클래스들의 경로명
import javax.swing.event.*; // 스윙 이벤트를 위한 경로명
```
#### Swing 프레임
### 스윙 프레임 : 모든 스윙 컴포넌트를 닫는 최상위 컨테이너
* JFrame을 상속받아 구현
* 컴포넌트들은 화면에 보이려면 스윙 프레임에 부착되어야 함
* 프레임을 닫으면 프레임에 부착된 모든 컴포넌트가 보이지 않게 됨
### 스윙 프레임(JFrame) 기본 구성
* 프레임 : 스윙 프로그램의 기본 틀
* 메뉴바 : 메뉴들이 부착되는 공간
* 컨텐트팬 : GUI 컴포넌트들이 부착되는 공간

### 프레임 만들기, JFrame 클래스 상속
* 스윙 프레임
* JFrame 클래스를 상속받은 클래스 작성
* 프레임의 크기 반드시 지정 : setSize() 호출
* 프레임을 화면에 출력하는 코드 반드시 필요 : setVisible(true) 호출

```
import javax.swing*;

public class MyFrame extends JFrame { //JFrame을 상속받은 Myframe 작성
    public MyFrame() {
        setTitle("300x300 스윙 프레임 만들기"); // 타이틀 설정

        set Size(300,300); // 프레임 크기 지정

        setVisible(true); // 프레임을 화면에 출력
    }
    public static void main(String []args){
        MyFrame mf = new MyFrame(); // MyFrame 객체 즉 스윙 프레임 생성
    }
}
```
### Swing 응용프로그램에서 main()의 기능과 위치
* 스윙 응용프로그램에서 main()의 기능 최소화 바람직
* 스윙 응용프로그램이 실행되는 시작점으로서의 기능만
* 스윙 프레임을 생성하는 정도의 코드로 최소화
```
public static void main(String[]args){
    MyFrame frame = new MyFrame(); //스윙 프레임 생성
}
```
* 프레임 객체를 생성하고 사용하지 않기 때문에 worrying이 발생
```
public static void main(String[]args) {
    // Ex81MyFrame frame = new Ex81MyFrame();
    javax.swing.SwingUtilities.invokeLater(( ->)){
        new Ex81MyFrame(); //EDT에서 프레임 생성
    }
}
```
### 프레임에 컴포넌트 붙이기
* 타이들 달기 -super()나 setTitle() 이용
* 컨텐트팬에 컴포넌트 달기
* 컨텐트팬 - 스윙 컴포넌트들이 부착되는 공간
* 컨텐트팬 알아내기 : 스윙 프레임에 붙은 디폴트 컨텐트팬 알아내기
* 컨텐트팬에 컴포넌트 붙이기
* 컨텐트팬 변경

### 컨텐트팬에 대한 JDK 1.5 이후의 추가 사항
* JDK 1.5 이전
* 프레임의 컨텐트팬을 알아내어, 반드시 컨텐트팬에 컴포넌트 부착
```
Container c = frame.getContentPane();
c.add(new JButton("Click")); //컨텐트팬에 직접 컴포넌트 부착
```
* JDK 1.5 이후 추가된 사항
* 프레임에 컴포넌트를 부착하면 프레임이 대신 컨텐트팬에 부착
```
frame.add(new JButton("Click"));
//프레임이 버튼 컴포넌트를 컨텐트팬에 대신 부착
```
* JDK 1.5 이전처럼 직접 컨텐트팬에 컴포넌트를 부착하는 것이 바람직함
* 컨텐트팬 다루기 능력 필요
* 컴포넌트의 부모가 프레임이 아닌, 컨텐트팬임을 알고 명확히 사용 필요

### Swing 응용프로그램의 종료
* 응용프로그램 내에서 스스로 종료하는 방법
```
System.exit(0); // 언제 어디서나 무조건 종료
```
* 프레임의 오른쪽 상단의 종료버튼(x) 클릭되면 어떤 일이 일어나는가?
* 프레임 종료, 프레임 윈도우를 닫음 : 프레임이 화면에서 보이지 않게 됨
* 프레임이 보이지 않게 되지만 응용프로그램 종료 X
* 키보드나 마우스 입력 받지 못 함
* 다시 setVisible(true)를 호출하면 보이고 이전처럼 작동
* 프레임 종료버튼이 클릭될 때, 프레임과 함께 프로그램을 종료 시키는 방법
```
frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
```
### 컨테이너와 배치, 배치관리자 개념
* 컨테이너의 배치관리자
* 컨테이너마다 하나의 배치관리자 존재
* 컨테이너에 부착되는 컴포넌트의 위치와 크기 결정
* 컨테이너의 크기가 변경되면, 컴포넌트의 위치와 크기 재결정

#### 배치 관리자 대표 유형 4가지
### FlowLayout 배치관리자
* 컴포넌트가 삽입되는 순서대로 왼쪽에서 오른쪽으로 배치
* 배치할 공간이 없으면 아래로 내려와서 반복
### BorderLayout 배치관리자
* 컨테이너의 공간을 동,서,남,북 중앙의 5개 영역으로 나눔
### GridLayout 배치관리자
* 컨테이너를 프로그램에서 설정한 동일한 크기의 2차워 격자로 나눔
* 컴포넌트는 삽입 순서대로 좌에서 우로, 다시 위에서 아래로 배치
###
CardLayout
* 컨테이너의 공간에 카드를 쌓아 놓은 듯이 컴포넌트를 포개어 배치
### 컨테이너에 새로운 배치관리자 설정
* setLayout(LayoutManager lm) 메소드 호출 : lm을 새로운 배치관리자로 설정
* JPanel 컨테이너에 BorderLayout 배치관리자 설정
```
JPanel p = new JPanel();
p.setLayout(new BorderLayout()); //JPanel에 BoderLayout 설정
```
```
Container c = frame.getConentPane(); //프레임의 컨텐트팬 알아내기
c.setLayout(new FlodwLayout()); //컨텐트팬에 FlowLayout 설정
```
```
c.setLayout(FlowLayout); //오류
```
### FlowLayout 배치관리자
* 배치방법 
* 컴포넌트를 컨테이너 내에 왼쪽에서 오른쪽으로 배치
* 다시 위에서 아래로 순서대로 배치
```
container.setLayout(new FlowLayout());
container.add(new JButton("add"));
container.add(new JButton("sub"));
container.add(new JButton("mul"));
container.add(new JButton("div"));
container.add(new JButton("Calcuate"));
```
### BorderLayout 배치관리자
* 배치방법 - 컨테이너 공간을 5구역으로 분할, 배치 : 동, 서, 남, 북, 중앙
* 배치방법 
* add(Component comp, int index) : comp를 index의 공간에 배치
```
container.setLayout(new BorderLayout());
container.add(new JButton("div"), BorderLayout.WEST);
container.add(new JButton("Calcuate"), BorderLayout.CENTER);
```
### GridLayout 생성자
* 생성자
* GridLayout()
* GridLayout(int rows, int cols)
* GridLayout(int rows, int cols, int hGap, int vGap)

* rows 격자의 행수 (디폴트 : 1)
* cols : 격자의 열수 (디폴트 : 1)
* hGap : 좌우 두 컴포넌트 사이의 수평 간격, 픽셀 단위 (디폴트 : 0)
* vGap : 상하 두 컴포넌트 사이의 수직 간격, 픽셀 단위(디폴트 : 0)
* rows x cols 만큼의 셀을 가진 격자로 컨테이너 공간을 분할, 배치

### 배치관리자 없는 컨테이너
#### 배치관리자가 없는 컨테이너가 필요한 경우
* 응용프로그램에서 직접 컴포넌트의 크기가 위치를 결정하고자 하는 경우
* 1. 컴포넌트의 크기나 위치를 개발자 임의로 결정하고자 하는 경우
* 2. 게임 프로그램과 같이 시간이나 마우스/키보드의 입력에 따라 컴포넌트들의 위치와 크기가 수시로 변하는 경우
* 3. 여러 컴포넌트들이 서로 겹쳐 출력하고자 하는 경우

* 컨테이너의 배치 관리자 제거 방법
* container.setLayout(null);
```
JPanel p = new JPanel();
p.setLayout(null); // JPanel의 배치관리자 삭제
```

* 컨테이너의 배치관리자가 없어지면, 컴포넌트에 대한 어떤 배치도 없음
* 추가된 컴포넌트의 크기가 0으로 설정, 위치가 예측할 수 없게 됨
```
//패널 p에는 배치관리자가 없으면 아래 두 버튼은 배치되지 않는다.

p.add(new JButton("click")); //폭과 높이가 0인 상태로 화면에 보이지 않는다
p.add(new JButton("me!")); //폭과 높이가 0인 상태로 화면에 보이지 않는다
```
### 컴포넌트의 절대 위치와 크기 설정
#### 배치관리자가 없는 컨테이너에 컴포넌트를 삽입할 때
* 프로그램에서 컴포넌트의 절대 크기와 위치 설정
* 컴포넌트들이 서로 겹치게 할 수 있음
#### 컴포넌트의 크기와 위치 설정 메소드
* void setSize(int width, int height)//컴포넌트 크기 설정
* void setLocation(int x, int y)// 컴포넌트 위치 설정
* void setBounds(int x, int y, int width, int height)// 위치와 크기 동시 설정
```
JPanel p - new JPanel();
p.setLayout(null); //패널 p의 배치관리자 제거

JButton clickButton = new JButton("Click");
clickButton.setSize(100,40); //버튼크기 100x40으로 지정
clickButton.setLocation(50,50); //버튼위치를 50,50으로 지정
p.add(clickButton); //패널 내 50,50에 100x40 크기의 버튼출력
```
### 9장 자바의 이벤트 처리
#### 이벤트 기반 프로그래밍
* 이벤트의 발생에 의해 프로그램 흐름이 결정되는 방식
* 이벤트가 발생하면 이벤트를 처리ㅏ는 루틴(이벤트 리스너) 실행
* 실행될 코드는 이벤트의 발생에 의해 전적으로 결정
* 반대 개념: 배치 실행
- 프로그램의 개발자가 프로그램의 흐름을 결정하는 방식
* 이벤트 종류
- 사용자의 입력 : 마우스 드래그, 클릭, 키보드 누름 등
- 센서로부터의 입력, 네트워크로부터 데이터 송수신
- 다른 응용프로그램이나 다른 스레드로부터의 메시지
* 이벤트 기반 응용 프로그램의 구조
- 각 이벤트마다 처리하는 리스너 코드 보유
* GUI 응용프로그램은 이벤트 기반 프로그래밍으로 작성됨
- GUI 라이브러리 종류 : C++의 MFC, C# GUI, Visual Basic, X Window, Android 등
* 자바의 AWT와 Swing
### 자바 스윙 프로그램에서 이벤트 처리 과정
* 이벤트 발생
- 예 : 마우스의 움직임 혹인 키보드입력
* 이벤트 객체 생성
- 현재 발새한 이벤트에 대한 정보를 가진 객체
* 응용프로그램에 작성된 이벤트 리스너 찾기
* 이번트 리스너 실행
- 리스너에 이벤트 객체 전달
- 리스너 코드 실행
### 이벤트 객체
* 이벤트 객체
- 발생한 이벤트에 관한 정보를 가진 객체
- 이벤트 리스너에 전달
- 이벤트 리스너 코드가 발생한 이벤트에 대한 상황을 파악할 수 있게 함
* 이벤트 객체가 포함하는 정보
- 이벤트 종류와 이벤트 소스
- 이벤트가 발생한 화면 좌표, 컴포넌트 내 좌표
- 이벤트가 발생한 버튼이나 메뉴 아이템의 문자열
- 클릭된 마우스 버튼 번호 및 마우스의 클릭 횟수
- 키의 코드 값과 문자 값
- 체크박스, 라디오버튼 등과 같은 컴포넌트에 이벤트가 발생했다면 체크 상태

* 이벤트 소스를 알아 내는 메소드 : Object get Source()
- 발생한 이벤트의 소스 컴포넌트 리턴
- Object 타입으로 리턴하므로 캐스팅하여 사용
- 모든 이벤트 객체에 대해 적용

### 리스너 인터페이스
#### 이벤트 리스너 : 이벤트를 처리하는 자바 프로그램 코드, 클래스로 작성
* 자바는 다양한 리스너 인터페이스 제공
- ActionListener 인터페이스 - 버튼 클릭 이벤트를 처리하기 위한 인터페이스
```
interface ActionListener { // 아래 메소드를 개발자가 구현해야 함
    public void actionPerformed(ActionEvent e); //Action 이벤트 발생시 호출
}
```


- MouseListener 인터페이스 - 마우스 조작에 따른 이벤트를 처리하기 위한 인터페이스

* 사용자의 이벤트 리스너 작성
- 자바의 리스너 인터페이스를 상속받아 구현
- 리스너 인터페이스의 모든 추상 메소드 구현

### 이벤트 리스너 작성 과정 사례
* 이벤트와 이벤트 리스너 선택
- 버튼 클릭을 처리하고자 하는 경우
- 이벤트 : Action 이벤트, 이벤트 리스너 : ActionListener
* 이벤트 리스너 클래스 작성 : ActionListener 인터페이스 구현
```
class MyActionListenner implements ActionListener {
    public void actionPerformed(ActionEvent e){ //버튼이 클릭될 때 호출되는 메소드
        JButton b =(JButton)e.getSource(); //사용자가 클릭한 버튼 알아내기
        if(b.getText()equals("Action)) //버튼의 문자열이 action인지 비교
        b.setText("액션"); //JButton의 setText()호출, 문자열변경
        else
        b.setText("Action"); //JButton의 setText() 호출 문자열변경
    }
}
```
* 이벤트 리스너 등록
- 이벤트를 받아 처리하고자 하는 컴포넌트에 이벤트 리스너 등록
- component.addXXXListener(listener)
* xxx : 이벤트 명, listener : 이벤트 리스너 객체
```
MyActionListener listener = new MyActionListener(); //리스너 인스턴스 생성
btn.addActionListener(listener); //리스너 등록
```
### 이벤트 리스너 작성 방법
* 독립 클래스로 작성
- 이벤트 리스너를 완전한 클래스로 작성
- 이벤트 리스너를 여러 곳에서 사용할 때 적합
* 내부 클래스로 작성
- 클래스 안에 멤버처럼 클래스 작성
- 이벤트 리스너를 특정 클래스에서만 사용할 때 적합
* 익명 클래스로 작성
- 클래스의 이름 없이 간단히 리스너 작성
- 클래스 조차 만들 필요 없이 리스너 코드가 간단한 경우에 적합

## 5월 22일
### StringBuffer 클래스
* 가변 스트링을 다루는 클래스
* 객체 생성 
StringBuffer sb = new StringBuffer("java");
* String 클래스와 달리 문자열 변경 가능
* 가변 크기의 버퍼를 가지고 있어 문자열 수정 가능
* 문자열의 수정이 많은 작업에 적합

```
String buffer sb =new StringBuffer("This");

sb.append(* is pencil); // sb = "This is pencil"
sb.insert(7, "my"); // sb= "This is my pencil"
sb.replace(8,10, "your"); // sb = "This is your pencil"
System.out.println(sb); // This is your pencil 출력
```
###
StringTokenizer 클래스
* 구분 문자를 기준으로 문자열을 분리하는 클래스
* 구분 문자 : 문자열을 구분할 때 사용되는 문자
* 토큰 : 구분 문자로 분리된 문자열
```
String query + "name- kitae&addr-seoul&age-21";
StringTokenizer st = new StringTokenizer(query, "&");
```
* st = name=kitae 토큰 1 
* addr = seoul 토큰 2
* age = 21 토큰3
* int count = st.countTokens(); 토큰 개수 알아내기 count = 3
String token = st.nextToken(); 다음 토큰 얻어내기 st = "name = kitae"
### StringTokenizer로 문자열 분리 사례
```
StringTokenizer st = new StringTokenizer(query, "&");
```
* st = name 토큰1
* kitae 토큰2
* addr 토큰3
* seoul 토큰4
* age 토큰5
* 21 토큰6
```
int count = st.countTokens(); 토큰 개수 알아내기 count = 6
String token = st.nextToken(); 다음 토큰 얻어내기 st = "name"
```
### Math 클래스
* 기본 산술 연산 메소드를 제공하는 클래스
* 모든 메소드는 static으로 선언
* . 클래스 이름으로 호출 가능
* Math.random() 메소드로 난수 발생
* random()은 0보다 크거나 같고 1.0보다 작은 실수 난수 발생
* 1에서 100까지의 랜덤 정수 10개를 발생시키는 코드 사례
```
for (int x=0; x(10; x++){
    int n = (int)(Math.random()*100 + 1); // 1~100까지의 랜덤 정수 발생
    System.out.prinln(n);
}
```
* java.util.random 클래스 이용하여 난수 발생 가능
```
Random r = new Random();
int n = r.nextint(); //음수 , 양수, 0포함 자바의 정수 범위 난수 발생
int m = r.nextint(100); //0에서 99사이(0,99포함)의 정수 난수 발생
```
### 7장
#### 컬렉션의 개념
* 요소라고 불리는 가변 개수의 객체들의 저장소
* 객체들의 컨테이너라고도 불림
* 요소의 개수에 따라 크기 자동 조절
* 요소의 삽입, 삭제에 따른 요소의 위치 자동 이동
* 고정 크기의 배열을 다루는 어려움 해소
* 다양한 객체들의 삽입, 삭제, 검색 등의 관리 용어
#### 컬렉션의 특징
* 1. 컬렉션은 제네릭 기법으로 구현
* 제네릭
* 특정 타입만 다루지 않고, 여러 종류의 타입으로 변신할 수 있도록 클래스나 메소드를 일반화 시키는 기법
* 클래스나 인터페이스 이름에 <E> <K> <V>등 타입 매개변수 포함
* 제네릭 컬렉션 사레: 벡터 Vector<E>
* <E>에서 E에 구체적인 타입을 주어 구체적 타입만 다루는 벡터로 활용
* 정수만 다루는 컬렉션 벡터 Vector<Integer>
* 문자열만 다루는 컬렉션 벡터 Vector<String>
* 2. 컬렉션의 요소는 객체만 가능
* int, char, double 등의 기본타입으로 구체화 불가
* 컬렉션 사레
```
Vector<int> v = new Vector<int>(); //컴파일 오류, int 사용 불가
Vector<integer> v = new Vector<integer>();
```
* ##### 제네릭의 기본 개념
* 제네릭
* jdk 1.5 부터 도입(2004)
* 모든 종류의 데이터 타입을 다룰 수 있도록 일반화된 타입 매개 변수로 클래스(인터페이스)나 메소드를 작성하는 기법
* c++의 템플릿과 동일
##### Vector <E>의 특성
* <E>에 사용할 요소의 특정 타입으로 구체화
* 배열을 가변 크기로 다룰 수 있게 하는 컨테이너
* 배열의 길이 제한 극복 
* 요소의 개수가 넘치면 자동으로 길이 조절
* 요소 객체들을 삽입, 삭제, 검색하는 컨테이너
* 삽입, 삭제에 따라 자동으로 요소의 위치 조정
* Vector에 삽입 가능한 것
* 객체, null
* 기본 타입의 값은 Wrapper 객체로 만들어 저장
* 객체 삽입은 벡터의 맨 뒤, 중간에 객체 삽입 가능
* 객체 삭제는 임의의 위치에 있는 객체 삭제 가능
##### 컬렉션과 자동 박싱/언박싱
* JDK 1.5 이전 - 기본 타입 데이터를 Wrapper 객체로 만들어 삽입
* 컬렉션으로부터 요소를 얻어올 때, Wrapper 클래스로 캐스팅 필요
* JDK 1.5부터 - 자동 박싱/언박싱 작동 - 기본 타입 값 삽입 가능
* But 타입 매개 변수를 깁본 타입으로 구체화할 수 X
##### 컬렉션 생성문의 진화 : JAVA7, JAVA 10
- java 7이전 - 
Vector<Integer> v = new - Vector<Integer>(); // java 7이전

java 7 이후
* 컴파일러의 타입 추론 기능 추가
* <> 다이아몬드 연산자에 타입 매개변수 생략
```
Vector<Integer> v = new Vector(); // 7부터 추가, 가능
var v = new Vector<Integer>(); // 10부터 추가 가능
```
##### Arraylist<E>
* 가변 크기 배열을 구현한 클래스
* <E> 에 요소로 사용할 특정 타입으로 구체화
* 벡터와 거의 동일
* 요소 삽입, 삭제, 검색 등 벡터 기능과 거의 동일
* 벡터와 달리 스레드 동기화 기능 없음
* 다수 스레드가 동시에 ArrayList에 접근할 때 동기화X
* 개발자가 스레드 동기화 코드 작성
##### ArrayList와 Vector 차이
✅ ArrayList와 Vector의 공통점
* 모두 동적으로 크기가 늘어나는 배열 기반의 리스트 클래스

* 항목	ArrayList	Vector
* 동기화 여부	❌ 비동기화 (스레드 안전하지 않음)	✅ 동기화 (스레드 안전함)
* 성능	빠름 (싱글 스레드에 적합)	느림 (동기화로 인한 오버헤드 발생)
* 기본 크기 증가	1.5배씩 증가 (newCapacity = old + old/2)	2배씩 증가
* 도입 시기	Java 1.2 (Collection Framework 포함)	Java 1.0 (초기부터 존재)
* 사용 권장 여부	✅ 현대 개발에서 추천	❌ 특별한 이유 없으면 지양

* 요즘은 ArrayList가 기본 선택

* Vector는 거의 사용하지 않으며, 멀티스레드 환경에서는 synchronizedList, CopyOnWriteArrayList 등의 다른 스레드 안전한 대안을 사용하는 것이 좋다

#### 컬렉션의 순차 검색을 위한 Integer
* Integer<E> 인터페이스
* 리스트 구조의 컬렉션에서 요소의 순차 검색을 위한 인터페이스
* Vector<E>, ArrayList<E>, LinkedList<E>가 상속받는 인터페이스
 * Iterator 객체 얻어내기
 * 컬렉션의 iterator() 메소드 호출: 해당 컬렉션을 순차 검색할 수 있는 Iterator 객체 리턴
 * 컬렉션 검색 코드

#####
* HashMap<K,V>
* 키와 값의 쌍으로 구성되는 요소를 다루는 컬렉션
* k : 키로 사용할 요소의 타입
* v : 값으로 사용할 요소의 타입
* - :키와 값이 한창으로 삽입

* 삽입 및 검색이 빠른 특징
* 요소 삽입 : put()메소드
* 요소 검색 : get()메소드

##### 제네릭 만들기
* 제네릭 클래스 작성 : 클래스 이름 옆에 일반화된 타입 매개 변수 추가
```
public class MyClass<T>{ // 제네릭 클래스 Myclass 선언, 타입 매개 변수
    T val; // var의 타입은 t
    void set(T a){
        val = a; // t 타입의 값 a를 val에 지칭
    }
    T get() {
        return val; //t 타입 값 val 리턴
    }
}
```
* 제네릭 객체 생성 및 활용
* 제네릭 타입에 구체적인 타입을 지정하여 객체를 생성하는 것을 구체화라 함
```
MyClass<String>s = new MyClass<String>(); //T를 String으로 구체화
s.set("hello");
System.out.println(s.get()); // hello 출력

MyClass<Integer>n = new MyClass<Integer>(); // T를 Integer로 구체화
n.set(5);
System.out.println(n.gert()); //숫자 5 출력
```

### 8장 자바 GUI 스윙 기초
#### 자바의 GUT
* GUI : 사용자가 편리하게 입출력 할 수 있도록 그래픽으로 화면 구성. 마우스나 키보드로 입력 받을 수 있도록 지원하는 사용자 인터페이스
* 자바 언어에서 GUI 응용프로그램 작성 : AWT와 SWING 패키지에 강력한 GUI 컴포넌트 제공

#### AWT 패키지
* 자바가 처음 나왔을 때 배포된 GUI 패키지 최근에 거의 사용 X 
* 중량 컴포넌트
* 그리기는 운영체제에 의해 이루어지며, 운영체제에 자원을 많이 소모하고 부담줌
* 운영체제가 직접 그리기 때문에 속도 빠름

#### Swing 패키지
* AWT 기술을 기반으로 작성된 자바 라이브러리
* 모든 AWT 기능 + 추가된 풍부하고 화려한 고급 컴포넌트
* AWT 컴포넌트를 모두 스윙으로 재작성
* AWT 컴포넌트 이름 앞에 J자를 덧붙임
* 순수 자바 언어로 구현
* 스윙 컴포넌트는 경량 컴포넌트
* 스윙 컴포넌트는 운영체제의 도움을 받지 않고, 직접 그리기 때문에 운영체제에 부담주지 않음
* 현재 자바의 GUI 표준으로 사용

20


## 5월 8일
### 추상 클래스 
#### 추상 메소드(abstract method)
* : abstract로 선언된 메소드, 메소드의 코드 x 원형만 선언
* abstract public String getName(); 추상 메소드
* abstract public String fail() { retunn "Good Bye"; } 추상 메소드 아님 컴파일 오류
#### 추상 클래스(abstract class)
* 추상 메소드를 가지며, abstract로 선언된 클래스
* 추상 메소드 없이 abstract로 선언한 클래스
### 추상 클래스의 인스턴스 생성 불가
* 추상 클래스 = 온전한 클래스X 인스턴스 생성 X
레퍼런스만 생성
### 추상 클래스의 상속과 구현
#### 추상 클래스 상속
* 추상 클래스를 상속받으면 추상 클래스 됨
* 서브 클래스도 abstract로 선언
#### 추상 클래스 구현
* 서브 클래스에서 슈퍼 클래스의 추상 메소드 구현(오버라이딩)
* 추상 클래스를 구현한 서브 클래스는 추상 클래스X
### 추상 클래스의 목적
* 상속을 위한 슈퍼 클래스로 활용
* 서브 클래스에서 추상 메소드 구현
* 다형성 실현
### 자바의 인터페이스
* 소프트웨어를 규격화된 모듈로 만들고, 인터페이스가 맞는 모듈을 조립하듯이 응용프로그램을 작성 하기위해서 사용.
* 클래스가 구현해야 할 메소드들이 선언되는 추상형
* 인터페이스 선언 : interface 키워드로 선언 public interface SerialDriver {...}
#### 자바 인터페이스에 대한 변화
* java 7까지 : 인터페이스는 상수와 추상 메소드로만 구성
* java 8부터 : 상수와 추상메소드 포함. default 메소드 포함(java 8). private 메소드 포함(java 9) static 메소드 포함 (java 9)
* 여전히 인터페이스에는 필드(멤버 변수) 선언 불가
#### 인터페이스의 구성 요소들의 특징
* 인터페이스의 구성 요소들
* 상수 : public만 허용, public static final 생략
* 추상 메소드 : public abstract 생략 가능
* default 메소드 
* 인터페이스에 코드가 작성된 메소드
* 인터페이스를 구현하는 클래스에 자동 상속
* public 접근 지정만 허용. 생략 가능
* private 메소드
* 인터페이스 내에 메소드 코드가 작성되어야 함
* 인터페이스 내에 있는 다른 메소드에 의해서만 호출 가능
* static 메소드
* public, private 모두 지정 가능. 생략하면 public
### 자바 인터페이스 특징
* 인터페이스의 객체 생성 불가
* new PhoneInterface(); // 오류. 인터페이스 PhoneInterface 객체생성불가
* 인터페이스 타입의 레퍼런스 변수 선언 가능
* PhoneInterface galaxy; // galaxy는 인터페이스에 대한 레퍼런스 변수
### 인터페이스 상속
* 인터페이스 간에 상속 가능 : 
* 인터페이스를 상속하여 확장된 인터페이스 작성 가능
* extends 키워드로 상속 선언
```
interface MobilePhoneInterface extends PhoneInterface {
    void sendSMS(); //추상 메소드 추가
    void receiveSMS(); // 추상 메소드 추가
}
```
* 인터페이스 다중 상속 허용 * 일반 상속에서 허용X
```
interface MusicPhoneInterface extends PhoneInterface, MP3Interface {
    ...........
}
```
### 인터페이스 구현
* 인터페이스의 추상 메소드를 모두 구현한 클래스 작성
* implements 키워드 사용
* 여러개의 인터페이스 동시 구현 가능
* 인터페이스 구현 사례
* PhoneInterface 인터페이스를 구현한 SamsungPhone 클래스
## 6장 시작 패키지 개념과 필요성
* 3명이 분담하여 자바 응용프로그램을 개발하는 경우, 동일한 이름의 클래스가 존재 가능성 있다. 합칠 때 오류 발생 가능성.
* 개발자가 서로 다른 디렉터리로 코드 관리하여 해결.
### 자바 패키지와 모듈이란?
#### 패키지
* class를 모아둔거
* 서로 관련된 클래스와 인터페이스를 컴파일한 클래스 파일들을 묶어 놓은 디렉터리
* 하나의 응용프로그램은 한 개 이상의 패키지로 작성
* 패키지는 jar 파일로 압축할 수 있음
#### 모듈
* 패키지를 모아둔거
* 여러 패키지와 이미지 등의 자원을 모아 놓은 컨테이너
* 하나의 모듈을 하나의 .jmod 파일에 저장
### java 9부터 모듈화 도입
* 플랫폼의 모듈화 : java 9부터 API의 모든 클래스들(자바 실행 환경)을 패캐지 기반에서 모듈들로 완전히 재구성
* 응용프로그램의 모듈화 : 클래스들은 패키지로 만들고, 다시 패키지를 모듈로 만듦 모듈 프로그래밍은 어렵고 복잡. 
### 자바의 모듈화의 목적
* java 9부터 자바 API를 여러 모듈(99개)로 분할 : java 8까지는 rt.jar의 한 파일에 모든 API 저장. # 현재 70개로 정리
* 응용프로그램이 실행할 때 꼭 필요한 모듈들로만 실행 환경 구축 : 메모리 자원이 열악한 작은 소형 기기에 꼭 필요한 모듈로 구성된 작은 크기의 실행 이미지를 만들기 위함
#### 모듈의 현실
* JAVA 9부터 전면적으로 도입
* 복잡한 개념
* 큰 자바 응용프로그램에는 개발, 유지보수 등에 적합
* 현실적으로 모듈로 나누어 자바 프로그래을 작성할 필요X
### 모듈화 작업은 매우 중요한 개념. 소규모 프로젝트부터 적용해야 대형 프로젝트 쉽게 도입, 활용 가능
### 패키지 사용하기, import문
* 다른 패키지에 작성된 클래스 사용
* import를 이용하지 않는 경우
* 소스에 클래스 이름의 완전 경로명 사용
* 필요한 클래스만 import
* import 패키지.클래스
* 소스에는 클래스 명만 명시하면 됨
* 패키지 전체를 import
* 소스 시작 부분에 패키지의 경로명 .* import
* import 패키지.*
* 소스에는 클래스 명만 명시
* import java.util.*;
* java.util 패키지 내의 모든 클래스만을 지정, 하위 패키지의 클래스는 포함X
### 패키지 만들기
* 클래스 파일(.class)저장되는 위치
* 클래스나 인터페이스가 컴파일 되면 클래스 파일(.class) 생성
* 클래스 파일은 패키지로 선언된 디렉터리에 저장
* 패키지 선언
* 소스 파일의 맨 앞에 컴파일 후 저장될 패키지 지정 - package 패키지명;
#### 디폴트 패키지
* package 선언문이 없는 자바 소스 파일의 경우
* 컴파일러는 클래스나 인터페이스를 디폴트 패키지에 소속시킴
* 디폴트 패키지 > 현재 디렉터리
#### 패키지의 운영 방법
* 패키지 이름은 도메인 기반으로 시작(일반 관례)형식 : com.회사이름.프로젝트명.기능명 - 충돌 방지 ( 전 세계 어디서든 유일한 패키지명 확보 가능) / 모듈별 분리 가능
* 기능/역할별로 하위 패키지를 구분 : utils. controller, service 등
* 디렉토리 구조와 package 선언은 정확히 일치해야 한다.
* import는 필요한 만큼만, * 전체 import는 피하는게 좋다.

## 4월 18일 5/1 보강
### static 메소드의 제약 조건 2
* static 메소드는 this 사용불가
* static 메소드는 객체 없이도 사용 가능, this 레퍼런스 사용 불가
* 못 붙이게 막아놓음
### final 클래스와 메소드
* final 클래스 - 더이상 클래스 상속 불가능
* final 메소드 - 더 이상 오버라이딩 불가능
### final 필드
* final 필드 : 상수 선언(고정값) 사용
* 상수 필드는선언 시에 초기 값 지정
* 상수 필드는 실행 중에 값 변경할 수 없다
### 상속의 필요성
* class Student 말하기 먹기 걷기 잠자기 공부하기
* class StudentWorker 말하기 먹기 걷기 잠자기 공부하기 일하기
* class Researcher 말하기 먹기 걷기 잠자기 연구하기
* class Professor 말하기 먹기 걷기 잠자기 연구하기 가르치기
### 클래스 상속과 객체
* 상속 선언 : extends 키워드 사용
* 부모 클래스를 물려받아 자식 클래스 확장
* 부모 클래스 - 슈퍼 클래스 / 자식 클래스 - 서브 클래스
### 서브 클래스 객체의 모양
* 슈퍼 클래스 객체와 서브 클래스의 객체는 별개
* 서브 클래스 객체는 슈퍼 클래스 멤버 포함
## 자바 상속의 특징
* 클래스 다중 상속 불허 # 하나의 클래스가 둘 이상의 부모 클래스를 동시 상속받는 것을 말함
* C++ 다중 상속 가능
* C++은 다중 상속으로 멤버가 중복 생성되는 문제 있음(다이아몬드 상속)
* . # 부모 클래스 간에 계층적 관계가 있을 경우 중복된 멤버 생성될 수 있음
* 모호성 문제 : 두 부모 클래스에 동일한 이름의 멤버(변수, 함수)가 존재할 경우, 어떤 부모의 멤버를 호출해야 할지 모호해짐
* 자바는 인터페이스의 다중 상속 허용
* 다중 상속과 유사한 기능 제공
* 모든 자바 클래스는 묵시적으로 Object클래스 상속
* java.lang.Object 클래스는 모든 클래스의 슈퍼 클래스
### 슈퍼 클래스의 멤버에 대한 서브 클래스의 접근
* 슈퍼 클래스의 private 멤버 : 서브 클래스 접근 불가
* 슈퍼 클래스의 디폴트 멤버 : 서브 클래스가 동일한 패키지에 있을 때, 접근 가능
* 슈퍼 클래스의 public 멤버 : 서브 클래스 항상 접근 가능
* 슈퍼 클래스의 protected 멤버 : - 같은 패키지 내의 모든 클래스 접근 허용 - 패키지 여부와 상관없이 서브 클래스 접근 가능
### protected 멤버
* protected 멤버에 대한 접근 : 같은 패키지의 모든 클래스에게 허용
* 상속되는 서브 클래스가 같은 패키지든 다른 패키지든 상관 없이 사용
### 서브 클래스 / 슈퍼 클래스의 생성자 호출과 실행
* 객체 생성 시:
서브 클래스의 객체가 생성되면 → 슈퍼 클래스 생성자 → 서브 클래스 생성자 순으로 모두 실행

* 호출 순서:
서브 클래스 생성자 호출 → 슈퍼 클래스 생성자 호출

* 실행 순서:
슈퍼 클래스 생성자 실행 → 서브 클래스 생성자 실행
### 서브 클래스와 슈퍼 클래스의 생성자 선택
#### 객체 생성 시 생성자 실행 순서
* 슈퍼 클래스 생성자 → 서브 클래스 생성자 순으로 실행됨

둘 다 반드시 실행됨 (각 클래스의 멤버 초기화를 위해)

#### 생성자 선택 방법
* 슈퍼/서브 클래스 모두 여러 생성자 작성 가능

* 어떤 생성자가 호출될지는 다음 중 하나로 결정됨:

* 명시적 선택
*  서브 클래스 생성자에서 super() 키워드로 슈퍼 클래스 생성자를 직접 호출

* 컴파일러에 의한 기본 선택
*  super()를 명시하지 않으면, 기본 생성자가 자동 호출됨
### 컴파일러에 의해 슈퍼 클래스의 기본 생성자가 묵시적 선택
* super()를 명시하지 않으면 → 컴파일러가 기본 생성자 자동 호출

* 슈퍼 클래스에 기본 생성자(A())가 존재해야만 가능
없다면 컴파일 에러 발생

### 슈퍼 클래스에 기본 생성자가 없어 오류 
* 기본 생성자가 없는 슈퍼 클래스를 상속할 경우,
→ 서브 클래스 생성자에서 반드시 super(매개변수)로 명시적 호출 필요
###
* 서브 클래스 생성자에서 super(...)를 명시하지 않으면 컴파일러가 슈퍼 클래스의 기본 생성자를 자동 호출함
* 이 원칙은 매개변수가 있는 생성자에서도 동일하게 적용됨
* 슈퍼 클래스에 기본 생성자가 없으면 오류 발생!
### super()로 슈퍼 클래스의 생성자 명시적 선택
* super()는 서브 클래스 생성자에서 슈퍼 클래스 생성자 호출 시 사용
* super(값)을 사용하면, 슈퍼 클래스의 특정 생성자 직접 선택 가능

* 서브 클래스 생성자의 가장 첫 줄에 위치해야 함

* 이 방식은 기본 생성자가 없거나, 특정 초기화가 필요할 때 필수
### 업캐스팅 개념
 * 하위 클래스의 레퍼런스는 상위 클래스를 가리킬 수 없지만, 상위 클래스의 레퍼런스는 하위 클래스를 가리킬 수 있다
### 업캐스팅
* 서브 클래스의 레퍼런스를 슈퍼 클래스 레퍼런스에 대입
* 슈퍼 클래스 레퍼런스로 서브 클래스 객체를 가리키게 되는 현상
* 생물이 들어가는 박스에 사람, 코끼리 넣어도 무방
- 사람이나 코끼리 모두 생물 상속 받음
### p = s 업케스팅
```
 Person[] people = new Person[3];
 people[0] = new Student("홍길동");
 people[1] = new Student("김영희");
 people[2] = new Person("이순신");
```

* 실제 사용보다는 업캐스팅의 제한점을 설명하기 위한 코드

* 실제 개발에서는 p = s 형식으로 단순 업캐스팅하는 경우는 드뭅니다.

* 여러 자식 클래스(Student 등)를 하나의 부모 타입(Person)으로 다루기 위해 사용

* Student, Person 등 여러 클래스 객체를 공통 부모 타입(Person) 배열에 담을 수 있음

* 접근은 Person 수준에서만 가능 (업캐스팅 특성상)
### 다운캐스팅
* 슈퍼 크래스 레퍼런스를 서브 클래스 레퍼런스에 대입
* 업캐스팅 된 것을 다시 원래대로 되돌리는 것
* 반드시 명시적 타입 변환 지정

```
#public class DowncastingEx {
    public static void main(String[] args) {
        Person p = new Student("이재문");  // 업캐스팅
        Student s;

        s = (Student)p;  // 다운캐스팅

        System.out.println(s.name);  // 정상 출력
        s.grade = "A";  // 정상 접근
    }
}
```
### 업캐스팅 레퍼런스로 객체 구별
* 업캐스팅된 레퍼런스로는 객체의 실제 타입 구분 어려움
* 슈퍼 클래스는 여러 서브 클래스에 상속되기 때문
```
class Person { }
class Student extends Person { }
class Researcher extends Person { }
class Professor extends Researcher { }
```

```
Person p = new Person();
Person p = new Student();   // 업캐스팅
Person p = new Professor(); // 업캐스팅
```
* 위 코드에서 p는 모두 Person 타입이지만, 실제로는 각각 다른 클래스의 인스턴스를 참조함.

* 따라서 p만 가지고는 현재 객체가 Person, Student, Professor 중 어떤 것인지 알 수 없음.

* 이런 경우 instanceof 연산자를 사용해서 실제 객체 타입을 확인할 수 있습니다
```
if (p instanceof Professor) {
    System.out.println("p는 Professor 객체입니다.");
} else if (p instanceof Student) {
    System.out.println("p는 Student 객체입니다.");
}
```
### instanceof 연산자 사용
* 레퍼런스가 가리키는 객체의 타입 식별 : 연산의 결과는 true / false의 불린 값으로 반환
```
Person p = new Professor();
```
```
if(p instanceof Person) //ture
if(p instanceof Student) //ture
if(p instanceof Researcher) //ture
if(p instanceof Professor) //ture
if("java" instanceof String) //ture
```
### 메소드 오버라이딩 개념
* 서브 클래스에서 슈퍼 클래스의 메소드 중복 작성
* 슈퍼 클래스의 메소드 무력화, 항상 서브 클래스에 오버라이딩한 메소드가 실행되록 보장된 / 메소드 무시하기로 번역되기도 함
* 오버라이딩 조건 - 슈퍼 클래스 메소드의 원형(메소드 이름, 인자 타입 및 개수, 리턴 타입) 동일하게 작성
### 오버라이딩 목적, 다형성 실현
* 하나의 인터페이스(같은이름)에 서로 다른 구현
* 슈퍼 클래스의 메소드를 서브 클래스에서 각각 목적에 맞게 다르게 구현
* 사례 : Shape의 draw()메소드를 Line, Rect, Circle에서 오버라이딩하여 다르게 구현
### 동적 바인딩 - 오버라이딩된 메소드 호출
* SuperObject 하나만 있는 응용프로그램의 경우 혹은 상속받은 경우 모두 동적 바인딩을 한다.
* 오버라이딩 메소드가 항상 호출된다.
* SuperObject는 키워드 X
### super 키워드로 슈퍼 클래스의 멤버 전근
* 슈퍼 클래스의 멤버를 접근할 때 사용되는 레퍼런스
* super.슈퍼클래스의멤버
* 서브 클래스에서만 사용
* 슈퍼 클래스의 필드 접근
* 슈퍼 클래스의 메소드 호출 시 super로 이루어지는 메소드 호출 : 정적 바인딩
### 오버로딩 오버라이딩




## 4월 17일 (7주차)
### this 레퍼런스
* 컴파일러에 의해 자동 관리, 개발자는 사용하기만 하면 됨
* this.멤버 형태로 멤버를 접근할 때 사용
* this()로 다른 생성자 호출
* 같은 클래스의 다른 생성자 호출
* 생성자 내에서만 사용 가능
* 생성자 코드의 제일 앞에 있어야 함
### 객체 배열
* 객체에 대한 레퍼런스 배열
* 자바의 객체배열 만들기 3단계
* 배열 레퍼런스 변수 선언
* 레퍼런스 배열 생성
* 배열의 각 원소 객체 생성
### 메소드
* 메소드는 C/C++ 함수와 동일
* 자바의 모든 메소드는 반드시 클래스 안에 있어야 함
* 접근 지정자 : 다른 클래스에서 메소드를 접근할 수 있는지 여부 선언
* public. private, protected, 디폴트 (접근 지정자생략)
* 매개 변수가 byte, int, double 등 기본 타입으로 선언되었을 때 호출자가 건네는 값이 매개 변수에 복사되어 전달. 실 인자 값은 변경되지 않음
* 인자 전달 - 배열 전달
* 배열 레퍼런스만 매개 변수에 전달 : 배열 통째로 전달되지 않음
* 객체가 전달되는 경우와 동일 : 매개 ㅂ ㅕㄴ수가 실인자의 배열 공유
### 메소드 오버로딩
* 한 클래스 내에서 두 개 이상의 이름이 같은 메소드 작성
* 메소드 이름 동일해야 함
* 매개 변수의 개수 혹은 타입이 달라야 함
* 리턴 타입은 오버로딩과 관련 없음
### 객체 치환 시 주의할 점
* 객체 치환은 객체 복사가 아니며, 레퍼런스의 복사이다.
```
int a = 10;          10
int b = 5;           
 5

a = b;               5

5
```
### 객체 소멸
* new로 할당 받은 객체와 메모리를 jvm(자바가상기계)로 되돌려 주는 행위
* 자바는 객체 소멸 연산자 없음
* 객체 소멸은 jvm의 고유한 역할
* C/C++에서는 할당 받은 객체를 개발자가 프로그램 내에서 삭제해야 함
* C/C++의 프로그램 작성을 어렵게 만드는 요인
* 자바에서는 사용하지 않는 객체나 배열을 돌려주는 코딩 책임으로부터 개발자 해방
### 가비지
* 가리키는 레퍼런스가 하나도 없는 객체
* 더 이상 접근할 수 없어 사용할 수 없게 된 메모리
* 가비지 컬렉션 : 자바 가상 기계의 가비지 컬렉터가 자동으로 가비지 수집, 반환
#### 가비지 컬렉션 
* JVM이 가비지 자동 회수
* 가용 메모리 공간이 일정 이하 부족해질 때
* 가비지를 수거하여 가용 메모리 공간 확보
* 가비지 컬렉터에 의해 자동 수행
* 강제 가비지 컬렉션 강제 수행 : System 또는  Runtime 객체의 gc() 메소드 호출
System.gc(); // 가비지 컬렉션 작동 요청
* JVM에 강력한 가비지 컬렉션 요청
* 그러나 JVM이 가비지 컬렉션 시점을 전적으로 판단
### 자바의 패키지 개념
* 구별하려고 비슷비슷한 애들 모아놓음(.class 파일)
* 상호 관련 있는 클래스 파일(컴파일된 .class)를 저장하여 관리하는 디렉터리
* 자바 응용프로그램은 하나 이상의 패키지로 구성
### 접근 지정자
* 자바의 접근 지정자 4가지 : private, protected, public, 디폴트(접근 지정자 생략)
* 목적
* 클래스나 일부 멤버를 공개하여 다른 클래스에서 접근하도록 허용
* 객체 지향 언어의 캡슐화 정책은 멤버를 보호
* 접근 지정은 캡슐화에 묶인 보호를 일부 해제할 목적으로 사용
* 접근 지정자에 따른 클래스나 멤버의 공개 범위
### 클래스 접근 지정
* 다른 클래스에서 사용하도록 허용할 지 지정
* public 클래스 : 다른 모드 클래스에게 접근 허용
* 디폴트 클래스(접근 지정자 생략) : 같은 패키지의 클래스에만 접근 허용 
```
public class World { // public 클래스}
class Local { //디폴트 클래스
}
```
* public 멤버 : 패키지에 관계 없이 모든 클래스에게 접근 허용
* private 멤버 : 동일 클래스 내에만 접근 허용. 상복 받은 서브 클래스에서 접근 불가
* protected 멤버 : 같은 패키지 내의 다른 모든 클래스에게 접근 허용 
상속 받은 서브 클래스는 다른 패키지에 이어도 접근 가능 
* 디폴트 멤버 : 같은 패키지 내의 다른 클래스에게 접근 허용
### static 멤버 선언
* 객체 생성과 non-static 멤버의 생성
:non static 멤버는 객체가 생설될 때, 객체마다 생긴다.
* non-static 멤버는 객체가 생성될 때마다 각각 생성되며,
### static 멤버의 생성
* static 멤버는 클래스에 하나만 존재하고 모든 객체가 공유합니다.
* 한글로 객체 영어로 인스턴스
### static 멤버 사용
* 클래스 이름으로 접근 가능
* StaticSample.m = 3; // 클래스 이름으로 static 필드 접근
* StaticSample.f(); // 클래스 이름으로 static 메소드 호출

* 객체의 멤버로 접근 가능
```
StaticSample b1 = new StaticSample();
b1.m = 3; // 객체 이름으로 static 필드 접근
b1.f(); // 객체 이름으로 static 메소드 호출
 non-static 멤버는 클래스 이름으로 접근 안 됨
StaticSample.n = 5; // n은 non-static 컴파일 오류
 StaticSample.g(); // g()는 non-static 컴파일 오류
non-static 모든 객체 멤버 생성, static 멤버 공유
```
### static의 활용 
* 전역 변수와 전역 함수를 만들 때 할용
* 공유 멤버를 만들 때 : static으로 선언한 멤버는 클래스의 객체들 사이에 공유
* 어떤 페이지에 가든 똑같은 결과
### static 메소드의 제약 조건 1
* static 메소드는 오직 static 멤버만 접근 가능
* 객체가 생성되지 않은 상황에서도 static 메소드는 실행될 수 있기 때문에 non-static 멤버 활용 불가
* non-static 메소드는 static 멤버 사용 가능







## 4월 10일 (6주차)
## 5주차 이어서
* try-catch-(finally 생략가능)
## 4장 클래스와 객체
* ㅂㅇㅃ ㄱㄱ 클래스 ㅂㅇㅃ 객체
### 세상 모든 것이 객체다
* 객체마다 고유한 특성(변수)과 행동(함수)을 가짐
* 클래스가 가지고 있는걸 객체가 상속받아 사용
* 컴퓨터 프로그램 객체 사례 
* 테트리스 게임의 각 블록들 / 한글 프로그램의 메뉴나 버튼들
### 자바의 객체 지향 특성 : 특성화
* 캡슐화 : 객체를 캡슐로 싸서 내부를 볼 수 없게 하는 것
* 객체의 가장 본질적인 특징 / 외부 접근으로부터 객체 보호
* 자바의 캡슐화 클래스 : 객체 모양을 선언한 틀 (캡슐화하는 틀)
* 객체 : 생성된 실체(instance) : 클래스 내에 메소드와 필드 구현
### : 상속
* 상위 객체의 속성이 하위 객체에 물려 줌
* 하위 객체가 상위 객체의 속성을 모두 가지는 관계
* 실세계의 상속 사례
* 나무 = 식물의 속성 생물 속성 둘 다 가짐
* 사람 = 생물 속성O 식물 속성X
* 상위 클래스의 멤버를 하위 크래스가 물려받음
* 상위 클래스 - 수퍼 클래스
* 하위 클래스 - 서브 클래스, 수퍼 클래스 코드의 재사용, 새로운 특성 추가 가능
### 다형성 
* 같은 이름의 메소드가 클래스 혹은 객체에 따라 다르게 구현되는 것
* 다형성 사례
* 메소드 오버로딩 : 한 클래스 내에서 같은 이름이지만 다르게 작동하는 여러 메소드
* 메소드 오버라이딩 : 슈퍼 클래스의 메소드를 동일한 이름으로 서브 클래스마다 다르게 구현 
### 객체 지향 언어의 목적
#### 소프트웨어의 생산성 향상
* 컴퓨터 산업 발전에 따라 소프트웨어의 생명 주기 단축
* 소프트웨어를 빠른 속도로 생산할 필요성 증대
#### 객체 지향 언어
* 상속, 다형성, 객체, 캡슐화 등 소프트웨어 재사용을 위한 여러 장치 내장
* 소프트웨어 재사용과 부분 수정 빠름
* 소프트웨어를 다시 만드는 부담 대폭 줄임
* 소프트웨어 생산성 향상
#### 실세계에 대한 쉬운 모델링
* 초기 프로그래밍 수학 계산/통계 처리 하는 등 처리 과정, 계산 절차 중요
* 현대 프로그래밍
* 컴퓨터가 산업 전반에 활용 / 실세계에서 발생하는 일을 프로그래밍
* 실세계에서는 절차나 과정보다물체(객체)들의 상호 작용으로 묘사하는 게 용이
* 객체 지향 언어 - 실세계의 일을 쉽게 프로그래밍하기 위한 객체 중심적 언어
### 절차 지향 프로그래밍
* 작업 순서를 표현하는 컴퓨터 명령 집합 
* 함수들의 집합으로 프로그램 작성
### 객체 지향 프로그래밍
* 컴퓨터가 수행하는 작업을 객체들 간의 상호 작용으로 표현
* 클래스 혹은 객체들의 집합으로 프로그램 작성
### 클래스와 객체
* 클래스 : 객체의 속성과 행위 선언. 객체의 설계도 혹은 틀
* 객체 : 클래스의 틀로 찍어낸 실체 / 프로그램 실행 중에 생성되는 실체
* 메모리 공간을 갖는 구체적인 실체 / 인스턴스 라고도 부름
* 사례 : 클래스 : 소나타자동차 / 객체 : 출고된 실제 소나타 100대
* 클래스 : 벽시계 / 객체 : 우리집 벽에 걸린 벽시계들
* 클래스 : 책상 / 객체 : 우리가 사용중인 실제 책상들
### 클래스
* class 키워드로 선언 멤버: 클래스 구성요소 필드(변수/ 명사) 메소드(함수/ 동사)
* 클래스 public 누구나 
### 객체 생성, 활용
* 레퍼러스 변수 선언 / circle pizza;
* 객체 생성 / new 연산자 이용 pizza = new circle
* 객체 멤버 접근 / . 연산자 이용
### 생성자 개념, 목적
* 객체가 생설될 때 초기화 목적으로 실행되는 메소드
* 객체가 생성되는 순간 자동 호출
### 생성자 종류
* 매개 변수 없고, 아무 작업 없이 단순 리턴하는 생성자
* 기본 생성자가 자동 생산되는 경우
* 클래스에 생성자가 하나도 선언되어 있지 않을 때
* 컴파일러에 의해 기본 생성자 자동 생성
```
class Circle {
    public Circle() {} // 기본 생성자
}
```


## 4월 3일 (5주차)
## for 문
* 횟수 정해지면 사용

### while 문(조건식)
* 조건식이 참인 동안 반복 실행
* for - 횟수 정해지면 for(구구단)
* while - 횟수 정해지지 않을 때 사용
* (반복 되는데 횟수 안 정해진 거) 
### do while 문 
* 조건식이 참인 동안 반복 실행 작업문은 한 번 반드시 실행
### 중첩 반복
* 반복문이 다른 반복문을 내포하는 구조 for 문을 이용한 이중 중첩 구조
### countinue 문
* 반복문을 빠져 나가지 않고 다음 반복으로 제어 변경
### break 문
* 반복문 하나를 즉시 벗어날 때 사용. 하나의 반복문만 벗어남
* 중첩 반복의 경우 안쪽 반복문의 break 문이 실행되면 안쪽 반복문만 벗어남
### 자바 배열(array)
* 인덱스와 인덱스와 대응하는 데이터들로 이루어진 자료 구조로한 번에 많은 메모리 공간 선언
* 같은 타입의 데이터들이 순차적으로 저장되는 공간으로 인덱스를 이용하여 원소 데이터 접근
* 반복문을 이용하여 처리하기에 적합한 자료 구조
* 배열 선언, 생성
int(배열타입) intArrary(배열에 대한 래퍼런스 변수) [];(배열 선언)
* 생성 intArray(배열에 대한 레퍼런스 변수) = new(배열 생성) int (타입) [5];(원소 개수)
* 배열 선언 및 생성 디테일 - 배열은 선언과 생성의 두 단계 필요 : 선언 동시 생성O
* 배열 선언 - 배열의 이름 선언(배열 레퍼런스 변수 선언)
* 생성 - 배열 공간 할당 받는 과정
* 배열 초기화 - 배열 생성과 값 초기화
* 배열 인덱스 - 0부터, 크기 1부터 - 음수X 
* intArray = new int [5]; -(0 1 2 3 4 )
* intArray = new int [6]; -(0 1 2 3 4 5)
* 자바 배열 - 객체 처리 배열 크기는 배열 객체 length 필드에 저장
```
for(int i=0; i<intArray.lenght; i++) // intArray 배열 크기만큼 루프 돈다
```
### for-each 문
* 배열이나 나열의 원소를 순차 접근하는데 유용한 for 문
### 2차원 배열
* int intArray[2][5]; or int[2][5] intArray
* 2차원 배열 length 필드
* i. length - 2차원 배열의 행의 개수 - 2
* i[n].length - n번째 행의 열의 개수
* i[1].length - 1번째 행의 열의 개수 - 5 
### 메소드의 배열 리턴
* 배열의 레퍼런스만 리턴, 전체 리턴X
* 메소드의 리턴타입 - 리턴하는 배열 타입과 리턴 받는 배열 타입 일치 -리턴 타입에 배열의 크기 지정X
### 자바의 예외 처리, try-catch 문
* 예외 처리 : 2발생한 예외에 대해 개발자가 작성한 프로그램 코드에서 대응하는 것
* finally 블록은 생략 가능





## 3월 27일(4주차)
 * 소스 코드 - 우리가 사용하는 java코드(foo.txt .java)
 * 바이트코드 .class 파일 javac 소드코드 변환한 중간 코드 cpu 실행X JVM 실행해야함
 어셈블리어
 * 기계어 CPU 실행O 0,1 이진 코드 - 운영체재와 CPU 아키텍처 등에 따라 다름 16진수 형태 기계어
 * 식별자 - 클래스, 변수, 상수, 메소드 등에 붙이는 이름 _ $ 가능 유니코드 문자 가능 대소문자 구별
 * Java 데이터 타입 기본자료형 8개있음 논리 문자 정수 실수 타입 문자열 String 클래스로 표현 # 리터널 - 소스 코드 중 특정한 자료형의 값
 * 참조 자료형 = 주소를 저장 할 수 없음 - 주소 없지만 JVM이 주소로 안내 객체를 참조하는 변수 유형 - 힙(Heap)영역에 저장된 객체 메모리 주소 가르킴 
 기본 자료형 - 스택(Stack)저장
 New 키워드 객체(인스턴스)생성 -참조 자료형 선언 -JVM이 객체 주소 저장
 * 메모리 안정성, 가비지 컬렉션 지원, 코드의 단순화, 및 가독성 향상, 보안 강화, 다중 플랫폼 지원
 * 메모리의 구조 힙 heap fifo(first in first out) 프로그래머가 직접 공간 할당 해제하는 메모리 공간
 java-jvm 담당
 스택 stack lifo() 프로그램이 자동 사용 임시메모리
 힙-스택 침범 힙 오버플로우 스택 힙 침범 스택 오버플로우
 * 변수 선언 값 임시 저장 
 int(데이터) price(변수)
상수 final 키워드 사용
final(상수선언) int(데이터타입) PI(상수이름) == 3.141592(초기화)
* var 타입 생략 변수 선언
* 증감연산자 많이써요
* 



## 3월20일(3주차)




#### rename.md 파일 편집
 * 이름 학번 h1 제일 위에 기재
 * 날짜(주차)
 * 배운내용 & 코드
 최근 날짜가 제일 위로 올라오게.



