# 이주영 202230140

## 4월 17일 (7주차)
### this 레퍼런스
* 컴파일러에 의해 자동 관리, 개발자는 사용하기만 하면 됨
* this.멤버 형태로 멤버를 접근할 때 사용
* this()로 다른 생성자 호출
* 같은 클래스의 다른 생성자 호출
* 생성자 내에서만 사용 가능
* 생성자 코드의 제일 앞에 있어야 함
### 객체 배열
* 객체에 대한 레퍼런스 배열
* 자바의 객체배열 만들기 3단계
* 배열 레퍼런스 변수 선언
* 레퍼런스 배열 생성
* 배열의 각 원소 객체 생성
### 메소드
* 메소드는 C/C++ 함수와 동일
* 자바의 모든 메소드는 반드시 클래스 안에 있어야 함
* 접근 지정자 : 다른 클래스에서 메소드를 접근할 수 있는지 여부 선언
* public. private, protected, 디폴트 (접근 지정자생략)
* 매개 변수가 byte, int, double 등 기본 타입으로 선언되었을 때 호출자가 건네는 값이 매개 변수에 복사되어 전달. 실 인자 값은 변경되지 않음
* 인자 전달 - 배열 전달
* 배열 레퍼런스만 매개 변수에 전달 : 배열 통째로 전달되지 않음
* 객체가 전달되는 경우와 동일 : 매개 ㅂ ㅕㄴ수가 실인자의 배열 공유
### 메소드 오버로딩
* 한 클래스 내에서 두 개 이상의 이름이 같은 메소드 작성
* 메소드 이름 동일해야 함
* 매개 변수의 개수 혹은 타입이 달라야 함
* 리턴 타입은 오버로딩과 관련 없음
### 객체 치환 시 주의할 점
* 객체 치환은 객체 복사가 아니며, 레퍼런스의 복사이다.
int a = 10;          10
int b = 5;           
                      5

a = b;               5

                     5
### 객체 소멸
* new로 할당 받은 객체와 메모리를 jvm(자바가상기계)로 되돌려 주는 행위
* 자바는 객체 소멸 연산자 없음
* 객체 소멸은 jvm의 고유한 역할
* C/C++에서는 할당 받은 객체를 개발자가 프로그램 내에서 삭제해야 함
* C/C++의 프로그램 작성을 어렵게 만드는 요인
* 자바에서는 사용하지 않는 객체나 배열을 돌려주는 코딩 책임으로부터 개발자 해방
### 가비지
* 가리키는 레퍼런스가 하나도 없는 객체
* 더 이상 접근할 수 없어 사용할 수 없게 된 메모리
* 가비지 컬렉션 : 자바 가상 기계의 가비지 컬렉터가 자동으로 가비지 수집, 반환
#### 가비지 컬렉션 
* JVM이 가비지 자동 회수
* 가용 메모리 공간이 일정 이하 부족해질 때
* 가비지를 수거하여 가용 메모리 공간 확보
* 가비지 컬렉터에 의해 자동 수행
* 강제 가비지 컬렉션 강제 수행 : System 또는  Runtime 객체의 gc() 메소드 호출
System.gc(); // 가비지 컬렉션 작동 요청
* JVM에 강력한 가비지 컬렉션 요청
* 그러나 JVM이 가비지 컬렉션 시점을 전적으로 판단
### 자바의 패키지 개념
* 구별하려고 비슷비슷한 애들 모아놓음(.class 파일)
* 상호 관련 있는 클래스 파일(컴파일된 .class)를 저장하여 관리하는 디렉터리
* 자바 응용프로그램은 하나 이상의 패키지로 구성
### 접근 지정자
* 자바의 접근 지정자 4가지 : private, protected, public, 디폴트(접근 지정자 생략)
* 목적
* 클래스나 일부 멤버를 공개하여 다른 클래스에서 접근하도록 허용
* 객체 지향 언어의 캡슐화 정책은 멤버를 보호
* 접근 지정은 캡슐화에 묶인 보호를 일부 해제할 목적으로 사용
* 접근 지정자에 따른 클래스나 멤버의 공개 범위
### 클래스 접근 지정
* 다른 클래스에서 사용하도록 허용할 지 지정
* public 클래스 : 다른 모드 클래스에게 접근 허용
* 디폴트 클래스(접근 지정자 생략) : 같은 패키지의 클래스에만 접근 허용 public class World { // public 클래스}
class Local { //디폴트 클래스
}
* public 멤버 : 패키지에 관계 없이 모든 클래스에게 접근 허용
* private 멤버 : 동일 클래스 내에만 접근 허용. 상복 받은 서브 클래스에서 접근 불가
* protected 멤버 : 같은 패키지 내의 다른 모든 클래스에게 접근 허용 
상속 받은 서브 클래스는 다른 패키지에 이어도 접근 가능 
* 디폴트 멤버 : 같은 패키지 내의 다른 클래스에게 접근 허용
### static 멤버 선언
* 객체 생성과 non-static 멤버의 생성
:non static 멤버는 객체가 생설될 때, 객체마다 생긴다.
* non-static 멤버는 객체가 생성될 때마다 각각 생성되며,
### static 멤버의 생성
* static 멤버는 클래스에 하나만 존재하고 모든 객체가 공유합니다.
* 한글로 객체 영어로 인스턴스
### static 멤버 사용
* 클래스 이름으로 접근 가능
* StaticSample.m = 3; // 클래스 이름으로 static 필드 접근
* StaticSample.f(); // 클래스 이름으로 static 메소드 호출
* 객체의 멤버로 접근 가능
StaticSample b1 = new StaticSample();
b1.m = 3; // 객체 이름으로 static 필드 접근
b1.f(); // 객체 이름으로 static 메소드 호출
* non-static 멤버는 클래스 이름으로 접근 안 됨
StaticSample.n = 5; // n은 non-static 컴파일 오류
* StaticSample.g(); // g()는 non-static 컴파일 오류
* non-static 모든 객체 멤버 생성, static 멤버 공유
### static의 활용 
* 전역 변수와 전역 함수를 만들 때 할용
* 공유 멤버를 만들 때 : static으로 선언한 멤버는 클래스의 객체들 사이에 공유
* 어떤 페이지에 가든 똑같은 결과
### static 메소드의 제약 조건 1
* static 메소드는 오직 static 멤버만 접근 가능
* 객체가 생성되지 않은 상황에서도 static 메소드는 실행될 수 있기 때문에 non-static 멤버 활용 불가
* non-static 메소드는 static 멤버 사용 가능







## 4월 10일 (6주차)
## 5주차 이어서
* try-catch-(finally 생략가능)
## 4장 클래스와 객체
* ㅂㅇㅃ ㄱㄱ 클래스 ㅂㅇㅃ 객체
### 세상 모든 것이 객체다
* 객체마다 고유한 특성(변수)과 행동(함수)을 가짐
* 클래스가 가지고 있는걸 객체가 상속받아 사용
* 컴퓨터 프로그램 객체 사례 
* 테트리스 게임의 각 블록들 / 한글 프로그램의 메뉴나 버튼들
### 자바의 객체 지향 특성 : 특성화
* 캡슐화 : 객체를 캡슐로 싸서 내부를 볼 수 없게 하는 것
* 객체의 가장 본질적인 특징 / 외부 접근으로부터 객체 보호
* 자바의 캡슐화 클래스 : 객체 모양을 선언한 틀 (캡슐화하는 틀)
* 객체 : 생성된 실체(instance) : 클래스 내에 메소드와 필드 구현
### : 상속
* 상위 객체의 속성이 하위 객체에 물려 줌
* 하위 객체가 상위 객체의 속성을 모두 가지는 관계
* 실세계의 상속 사례
* 나무 = 식물의 속성 생물 속성 둘 다 가짐
* 사람 = 생물 속성O 식물 속성X
* 상위 클래스의 멤버를 하위 크래스가 물려받음
* 상위 클래스 - 수퍼 클래스
* 하위 클래스 - 서브 클래스, 수퍼 클래스 코드의 재사용, 새로운 특성 추가 가능
### 다형성 
* 같은 이름의 메소드가 클래스 혹은 객체에 따라 다르게 구현되는 것
* 다형성 사례
* 메소드 오버로딩 : 한 클래스 내에서 같은 이름이지만 다르게 작동하는 여러 메소드
* 메소드 오버라이딩 : 슈퍼 클래스의 메소드를 동일한 이름으로 서브 클래스마다 다르게 구현 
### 객체 지향 언어의 목적
#### 소프트웨어의 생산성 향상
* 컴퓨터 산업 발전에 따라 소프트웨어의 생명 주기 단축
* 소프트웨어를 빠른 속도로 생산할 필요성 증대
#### 객체 지향 언어
* 상속, 다형성, 객체, 캡슐화 등 소프트웨어 재사용을 위한 여러 장치 내장
* 소프트웨어 재사용과 부분 수정 빠름
* 소프트웨어를 다시 만드는 부담 대폭 줄임
* 소프트웨어 생산성 향상
#### 실세계에 대한 쉬운 모델링
* 초기 프로그래밍 수학 계산/통계 처리 하는 등 처리 과정, 계산 절차 중요
* 현대 프로그래밍
* 컴퓨터가 산업 전반에 활용 / 실세계에서 발생하는 일을 프로그래밍
* 실세계에서는 절차나 과정보다물체(객체)들의 상호 작용으로 묘사하는 게 용이
* 객체 지향 언어 - 실세계의 일을 쉽게 프로그래밍하기 위한 객체 중심적 언어
### 절차 지향 프로그래밍
* 작업 순서를 표현하는 컴퓨터 명령 집합 
* 함수들의 집합으로 프로그램 작성
### 객체 지향 프로그래밍
* 컴퓨터가 수행하는 작업을 객체들 간의 상호 작용으로 표현
* 클래스 혹은 객체들의 집합으로 프로그램 작성
### 클래스와 객체
* 클래스 : 객체의 속성과 행위 선언. 객체의 설계도 혹은 틀
* 객체 : 클래스의 틀로 찍어낸 실체 / 프로그램 실행 중에 생성되는 실체
* 메모리 공간을 갖는 구체적인 실체 / 인스턴스 라고도 부름
* 사례 : 클래스 : 소나타자동차 / 객체 : 출고된 실제 소나타 100대
* 클래스 : 벽시계 / 객체 : 우리집 벽에 걸린 벽시계들
* 클래스 : 책상 / 객체 : 우리가 사용중인 실제 책상들
### 클래스
* class 키워드로 선언 멤버: 클래스 구성요소 필드(변수/ 명사) 메소드(함수/ 동사)
* 클래스 public 누구나 
### 객체 생성, 활용
* 레퍼러스 변수 선언 / circle pizza;
* 객체 생성 / new 연산자 이용 pizza = new circle
* 객체 멤버 접근 / . 연산자 이용
### 생성자 개념, 목적
* 객체가 생설될 때 초기화 목적으로 실행되는 메소드
* 객체가 생성되는 순간 자동 호출
### 생성자 종류
* 매개 변수 없고, 아무 작업 없이 단순 리턴하는 생성자
* 기본 생성자가 자동 생산되는 경우
* 클래스에 생성자가 하나도 선언되어 있지 않을 때
* 컴파일러에 의해 기본 생성자 자동 생성
* class Circle {
    public Circle() {} // 기본 생성자
}



## 4월 3일 (5주차)
## for 문
* 횟수 정해지면 사용

### while 문(조건식)
* 조건식이 참인 동안 반복 실행
* for - 횟수 정해지면 for(구구단)
* while - 횟수 정해지지 않을 때 사용
* (반복 되는데 횟수 안 정해진 거) 
### do while 문 
* 조건식이 참인 동안 반복 실행 작업문은 한 번 반드시 실행
### 중첩 반복
* 반복문이 다른 반복문을 내포하는 구조 for 문을 이용한 이중 중첩 구조
### countinue 문
* 반복문을 빠져 나가지 않고 다음 반복으로 제어 변경
### break 문
* 반복문 하나를 즉시 벗어날 때 사용. 하나의 반복문만 벗어남
* 중첩 반복의 경우 안쪽 반복문의 break 문이 실행되면 안쪽 반복문만 벗어남
### 자바 배열(array)
* 인덱스와 인덱스와 대응하는 데이터들로 이루어진 자료 구조로한 번에 많은 메모리 공간 선언
* 같은 타입의 데이터들이 순차적으로 저장되는 공간으로 인덱스를 이용하여 원소 데이터 접근
* 반복문을 이용하여 처리하기에 적합한 자료 구조
* 배열 선언, 생성
int(배열타입) intArrary(배열에 대한 래퍼런스 변수) [];(배열 선언)
* 생성 intArray(배열에 대한 레퍼런스 변수) = new(배열 생성) int (타입) [5];(원소 개수)
* 배열 선언 및 생성 디테일 - 배열은 선언과 생성의 두 단계 필요 : 선언 동시 생성O
* 배열 선언 - 배열의 이름 선언(배열 레퍼런스 변수 선언)
* 생성 - 배열 공간 할당 받는 과정
* 배열 초기화 - 배열 생성과 값 초기화
* 배열 인덱스 - 0부터, 크기 1부터 - 음수X 
* intArray = new int [5]; -(0 1 2 3 4 )
* intArray = new int [6]; -(0 1 2 3 4 5)
* 자바 배열 - 객체 처리 배열 크기는 배열 객체 length 필드에 저장
* for(int i=0; i<intArray.lenght; i++) // intArray 배열 크기만큼 루프 돈다
### for-each 문
* 배열이나 나열의 원소를 순차 접근하는데 유용한 for 문
### 2차원 배열
* int intArray[2][5]; or int[2][5] intArray
* 2차원 배열 length 필드
* i. length - 2차원 배열의 행의 개수 - 2
* i[n].length - n번째 행의 열의 개수
* i[1].length - 1번째 행의 열의 개수 - 5 
### 메소드의 배열 리턴
* 배열의 레퍼런스만 리턴, 전체 리턴X
* 메소드의 리턴타입 - 리턴하는 배열 타입과 리턴 받는 배열 타입 일치 -리턴 타입에 배열의 크기 지정X
### 자바의 예외 처리, try-catch 문
* 예외 처리 : 2발생한 예외에 대해 개발자가 작성한 프로그램 코드에서 대응하는 것
* finally 블록은 생략 가능





## 3월 27일(4주차)
 * 소스 코드 - 우리가 사용하는 java코드(foo.txt .java)
 * 바이트코드 .class 파일 javac 소드코드 변환한 중간 코드 cpu 실행X JVM 실행해야함
 어셈블리어
 * 기계어 CPU 실행O 0,1 이진 코드 - 운영체재와 CPU 아키텍처 등에 따라 다름 16진수 형태 기계어
 * 식별자 - 클래스, 변수, 상수, 메소드 등에 붙이는 이름 _ $ 가능 유니코드 문자 가능 대소문자 구별
 * Java 데이터 타입 기본자료형 8개있음 논리 문자 정수 실수 타입 문자열 String 클래스로 표현 # 리터널 - 소스 코드 중 특정한 자료형의 값
 * 참조 자료형 = 주소를 저장 할 수 없음 - 주소 없지만 JVM이 주소로 안내 객체를 참조하는 변수 유형 - 힙(Heap)영역에 저장된 객체 메모리 주소 가르킴 
 기본 자료형 - 스택(Stack)저장
 New 키워드 객체(인스턴스)생성 -참조 자료형 선언 -JVM이 객체 주소 저장
 * 메모리 안정성, 가비지 컬렉션 지원, 코드의 단순화, 및 가독성 향상, 보안 강화, 다중 플랫폼 지원
 * 메모리의 구조 힙 heap fifo(first in first out) 프로그래머가 직접 공간 할당 해제하는 메모리 공간
 java-jvm 담당
 스택 stack lifo() 프로그램이 자동 사용 임시메모리
 힙-스택 침범 힙 오버플로우 스택 힙 침범 스택 오버플로우
 * 변수 선언 값 임시 저장 
 int(데이터) price(변수)
상수 final 키워드 사용
final(상수선언) int(데이터타입) PI(상수이름) == 3.141592(초기화)
* var 타입 생략 변수 선언
* 증감연산자 많이써요
### 자바 버추얼 머신, 멀티스레딩 이해
멀티스레딩은 프로그램이 여러개 실행될 때 동시에 수행하도록 하는 기술
멀티스레딩은 운영체제 도움 받지 않음

### 감지 컬렉션, 메모리 변환
감지컬렉션 = 사용하지 않는 메모리를 자동으로 정리하는 기능 = 반환 명령없이 메모리를 잡아먹지 않도록 함
메모리 변환 = 잠심 멈춤으로써 이뤄지면 실시간 응용 프로그램에 부적합



'''c
public class Ex3DoWhile {
    public static void main (String[] args) {
        char a = 'a'; 

        do {
            System.out.print(a);
            a = (char) (a + 1);
        } while (a <= 'z');
    }    
}
'''
#### README.md 파일 편집

* 이름 학번 h1 제일 위에 기재

* 날짜(주차)

* 배운내용&코드

* 최근 날짜가 제일 위로 올라오게


# h1 tag
## h2
### h3
#### h4
##### h5 
###### h6



---

* ㅣㅏㅏㅏㅏ
- ㅓㅓㅓㅓㅓㅓ


1. 이이이이이
2. 주주주주주
5. 영영영영영
