# 이주영 202230140

## 5월 8일
### 추상 클래스 
#### 추상 메소드(abstract method)
* : abstract로 선언된 메소드, 메소드의 코드 x 원형만 선언
* abstract public String getName(); 추상 메소드
* abstract public String fail() { retunn "Good Bye"; } 추상 메소드 아님 컴파일 오류
#### 추상 클래스(abstract class)
* 추상 메소드를 가지며, abstract로 선언된 클래스
* 추상 메소드 없이 abstract로 선언한 클래스
### 추상 클래스의 인스턴스 생성 불가
* 추상 클래스 = 온전한 클래스X 인스턴스 생성 X
레퍼런스만 생성
### 추상 클래스의 상속과 구현
#### 추상 클래스 상속
* 추상 클래스를 상속받으면 추상 클래스 됨
* 서브 클래스도 abstract로 선언
#### 추상 클래스 구현
* 서브 클래스에서 슈퍼 클래스의 추상 메소드 구현(오버라이딩)
* 추상 클래스를 구현한 서브 클래스는 추상 클래스X
### 추상 클래스의 목적
* 상속을 위한 슈퍼 클래스로 활용
* 서브 클래스에서 추상 메소드 구현
* 다형성 실현
### 자바의 인터페이스
* 소프트웨어를 규격화된 모듈로 만들고, 인터페이스가 맞는 모듈을 조립하듯이 응용프로그램을 작성 하기위해서 사용.
* 클래스가 구현해야 할 메소드들이 선언되는 추상형
* 인터페이스 선언 : interface 키워드로 선언 public interface SerialDriver {...}
#### 자바 인터페이스에 대한 변화
* java 7까지 : 인터페이스는 상수와 추상 메소드로만 구성
* java 8부터 : 상수와 추상메소드 포함. default 메소드 포함(java 8). private 메소드 포함(java 9) static 메소드 포함 (java 9)
* 여전히 인터페이스에는 필드(멤버 변수) 선언 불가
#### 인터페이스의 구성 요소들의 특징
* 인터페이스의 구성 요소들
* 상수 : public만 허용, public static final 생략
* 추상 메소드 : public abstract 생략 가능
* default 메소드 
* 인터페이스에 코드가 작성된 메소드
* 인터페이스를 구현하는 클래스에 자동 상속
* public 접근 지정만 허용. 생략 가능
* private 메소드
* 인터페이스 내에 메소드 코드가 작성되어야 함
* 인터페이스 내에 있는 다른 메소드에 의해서만 호출 가능
* static 메소드
* public, private 모두 지정 가능. 생략하면 public
### 자바 인터페이스 특징
* 인터페이스의 객체 생성 불가
* new PhoneInterface(); // 오류. 인터페이스 PhoneInterface 객체생성불가
* 인터페이스 타입의 레퍼런스 변수 선언 가능
* PhoneInterface galaxy; // galaxy는 인터페이스에 대한 레퍼런스 변수
### 인터페이스 상속
* 인터페이스 간에 상속 가능 : 
* 인터페이스를 상속하여 확장된 인터페이스 작성 가능
* extends 키워드로 상속 선언
interface MobilePhoneInterface extends PhoneInterface {
    void sendSMS(); //추상 메소드 추가
    void receiveSMS(); // 추상 메소드 추가
}
* 인터페이스 다중 상속 허용 * 일반 상속에서 허용X
interface MusicPhoneInterface extends PhoneInterface, MP3Interface {
    ...........
}
### 인터페이스 구현
* 인터페이스의 추상 메소드를 모두 구현한 클래스 작성
* implements 키워드 사용
* 여러개의 인터페이스 동시 구현 가능
* 인터페이스 구현 사례
* PhoneInterface 인터페이스를 구현한 SamsungPhone 클래스
## 6장 시작 패키지 개념과 필요성
* 3명이 분담하여 자바 응용프로그램을 개발하는 경우, 동일한 이름의 클래스가 존재 가능성 있다. 합칠 때 오류 발생 가능성.
* 개발자가 서로 다른 디렉터리로 코드 관리하여 해결.
### 자바 패키지와 모듈이란?
#### 패키지
* class를 모아둔거
* 서로 관련된 클래스와 인터페이스를 컴파일한 클래스 파일들을 묶어 놓은 디렉터리
* 하나의 응용프로그램은 한 개 이상의 패키지로 작성
* 패키지는 jar 파일로 압축할 수 있음
#### 모듈
* 패키지를 모아둔거
* 여러 패키지와 이미지 등의 자원을 모아 놓은 컨테이너
* 하나의 모듈을 하나의 .jmod 파일에 저장
### java 9부터 모듈화 도입
* 플랫폼의 모듈화 : java 9부터 API의 모든 클래스들(자바 실행 환경)을 패캐지 기반에서 모듈들로 완전히 재구성
* 응용프로그램의 모듈화 : 클래스들은 패키지로 만들고, 다시 패키지를 모듈로 만듦 모듈 프로그래밍은 어렵고 복잡. 
### 자바의 모듈화의 목적
* java 9부터 자바 API를 여러 모듈(99개)로 분할 : java 8까지는 rt.jar의 한 파일에 모든 API 저장. # 현재 70개로 정리
* 응용프로그램이 실행할 때 꼭 필요한 모듈들로만 실행 환경 구축 : 메모리 자원이 열악한 작은 소형 기기에 꼭 필요한 모듈로 구성된 작은 크기의 실행 이미지를 만들기 위함
#### 모듈의 현실
* JAVA 9부터 전면적으로 도입
* 복잡한 개념
* 큰 자바 응용프로그램에는 개발, 유지보수 등에 적합
* 현실적으로 모듈로 나누어 자바 프로그래을 작성할 필요X
### 모듈화 작업은 매우 중요한 개념. 소규모 프로젝트부터 적용해야 대형 프로젝트 쉽게 도입, 활용 가능
### 패키지 사용하기, import문
* 다른 패키지에 작성된 클래스 사용
* import를 이용하지 않는 경우
* 소스에 클래스 이름의 완전 경로명 사용
* 필요한 클래스만 import
* import 패키지.클래스
* 소스에는 클래스 명만 명시하면 됨
* 패키지 전체를 import
* 소스 시작 부분에 패키지의 경로명 .* import
* import 패키지.*
* 소스에는 클래스 명만 명시
* import java.util.*;
* java.util 패키지 내의 모든 클래스만을 지정, 하위 패키지의 클래스는 포함X
### 패키지 만들기
* 클래스 파일(.class)저장되는 위치
* 클래스나 인터페이스가 컴파일 되면 클래스 파일(.class) 생성
* 클래스 파일은 패키지로 선언된 디렉터리에 저장
* 패키지 선언
* 소스 파일의 맨 앞에 컴파일 후 저장될 패키지 지정 - package 패키지명;
#### 디폴트 패키지
* package 선언문이 없는 자바 소스 파일의 경우
* 컴파일러는 클래스나 인터페이스를 디폴트 패키지에 소속시킴
* 디폴트 패키지 > 현재 디렉터리
#### 패키지의 운영 방법
* 패키지 이름은 도메인 기반으로 시작(일반 관례)형식 : com.회사이름.프로젝트명.기능명 - 충돌 방지 ( 전 세계 어디서든 유일한 패키지명 확보 가능) / 모듈별 분리 가능
* 기능/역할별로 하위 패키지를 구분 : utils. controller, service 등
* 디렉토리 구조와 package 선언은 정확히 일치해야 한다.
* import는 필요한 만큼만, * 전체 import는 피하는게 좋다.

## 4월 18일 5/1 보강
### static 메소드의 제약 조건 2
* static 메소드는 this 사용불가
* static 메소드는 객체 없이도 사용 가능, this 레퍼런스 사용 불가
* 못 붙이게 막아놓음
### final 클래스와 메소드
* final 클래스 - 더이상 클래스 상속 불가능
* final 메소드 - 더 이상 오버라이딩 불가능
### final 필드
* final 필드 : 상수 선언(고정값) 사용
* 상수 필드는선언 시에 초기 값 지정
* 상수 필드는 실행 중에 값 변경할 수 없다
### 상속의 필요성
* class Student 말하기 먹기 걷기 잠자기 공부하기
* class StudentWorker 말하기 먹기 걷기 잠자기 공부하기 일하기
* class Researcher 말하기 먹기 걷기 잠자기 연구하기
* class Professor 말하기 먹기 걷기 잠자기 연구하기 가르치기
### 클래스 상속과 객체
* 상속 선언 : extends 키워드 사용
* 부모 클래스를 물려받아 자식 클래스 확장
* 부모 클래스 - 슈퍼 클래스 / 자식 클래스 - 서브 클래스
### 서브 클래스 객체의 모양
* 슈퍼 클래스 객체와 서브 클래스의 객체는 별개
* 서브 클래스 객체는 슈퍼 클래스 멤버 포함
## 자바 상속의 특징
* 클래스 다중 상속 불허 # 하나의 클래스가 둘 이상의 부모 클래스를 동시 상속받는 것을 말함
* C++ 다중 상속 가능
* C++은 다중 상속으로 멤버가 중복 생성되는 문제 있음(다이아몬드 상속)
* . # 부모 클래스 간에 계층적 관계가 있을 경우 중복된 멤버 생성될 수 있음
* 모호성 문제 : 두 부모 클래스에 동일한 이름의 멤버(변수, 함수)가 존재할 경우, 어떤 부모의 멤버를 호출해야 할지 모호해짐
* 자바는 인터페이스의 다중 상속 허용
* 다중 상속과 유사한 기능 제공
* 모든 자바 클래스는 묵시적으로 Object클래스 상속
* java.lang.Object 클래스는 모든 클래스의 슈퍼 클래스
### 슈퍼 클래스의 멤버에 대한 서브 클래스의 접근
* 슈퍼 클래스의 private 멤버 : 서브 클래스 접근 불가
* 슈퍼 클래스의 디폴트 멤버 : 서브 클래스가 동일한 패키지에 있을 때, 접근 가능
* 슈퍼 클래스의 public 멤버 : 서브 클래스 항상 접근 가능
* 슈퍼 클래스의 protected 멤버 : - 같은 패키지 내의 모든 클래스 접근 허용 - 패키지 여부와 상관없이 서브 클래스 접근 가능
### protected 멤버
* protected 멤버에 대한 접근 : 같은 패키지의 모든 클래스에게 허용
* 상속되는 서브 클래스가 같은 패키지든 다른 패키지든 상관 없이 사용
### 서브 클래스 / 슈퍼 클래스의 생성자 호출과 실행
* 객체 생성 시:
서브 클래스의 객체가 생성되면 → 슈퍼 클래스 생성자 → 서브 클래스 생성자 순으로 모두 실행

* 호출 순서:
서브 클래스 생성자 호출 → 슈퍼 클래스 생성자 호출

* 실행 순서:
슈퍼 클래스 생성자 실행 → 서브 클래스 생성자 실행
### 서브 클래스와 슈퍼 클래스의 생성자 선택
#### 객체 생성 시 생성자 실행 순서
* 슈퍼 클래스 생성자 → 서브 클래스 생성자 순으로 실행됨

둘 다 반드시 실행됨 (각 클래스의 멤버 초기화를 위해)

#### 생성자 선택 방법
* 슈퍼/서브 클래스 모두 여러 생성자 작성 가능

* 어떤 생성자가 호출될지는 다음 중 하나로 결정됨:

* 명시적 선택
*  서브 클래스 생성자에서 super() 키워드로 슈퍼 클래스 생성자를 직접 호출

* 컴파일러에 의한 기본 선택
*  super()를 명시하지 않으면, 기본 생성자가 자동 호출됨
### 컴파일러에 의해 슈퍼 클래스의 기본 생성자가 묵시적 선택
* super()를 명시하지 않으면 → 컴파일러가 기본 생성자 자동 호출

* 슈퍼 클래스에 기본 생성자(A())가 존재해야만 가능
없다면 컴파일 에러 발생

### 슈퍼 클래스에 기본 생성자가 없어 오류 
* 기본 생성자가 없는 슈퍼 클래스를 상속할 경우,
→ 서브 클래스 생성자에서 반드시 super(매개변수)로 명시적 호출 필요
###
* 서브 클래스 생성자에서 super(...)를 명시하지 않으면 컴파일러가 슈퍼 클래스의 기본 생성자를 자동 호출함
* 이 원칙은 매개변수가 있는 생성자에서도 동일하게 적용됨
* 슈퍼 클래스에 기본 생성자가 없으면 오류 발생!
### super()로 슈퍼 클래스의 생성자 명시적 선택
* super()는 서브 클래스 생성자에서 슈퍼 클래스 생성자 호출 시 사용
* super(값)을 사용하면, 슈퍼 클래스의 특정 생성자 직접 선택 가능

* 서브 클래스 생성자의 가장 첫 줄에 위치해야 함

* 이 방식은 기본 생성자가 없거나, 특정 초기화가 필요할 때 필수
### 업캐스팅 개념
 * 하위 클래스의 레퍼런스는 상위 클래스를 가리킬 수 없지만, 상위 클래스의 레퍼런스는 하위 클래스를 가리킬 수 있다
### 업캐스팅
* 서브 클래스의 레퍼런스를 슈퍼 클래스 레퍼런스에 대입
* 슈퍼 클래스 레퍼런스로 서브 클래스 객체를 가리키게 되는 현상
* 생물이 들어가는 박스에 사람, 코끼리 넣어도 무방
- 사람이나 코끼리 모두 생물 상속 받음
### p = s 업케스팅
* Person[] people = new Person[3];
* people[0] = new Student("홍길동");
* people[1] = new Student("김영희");
* people[2] = new Person("이순신");

* 실제 사용보다는 업캐스팅의 제한점을 설명하기 위한 코드

* 실제 개발에서는 p = s 형식으로 단순 업캐스팅하는 경우는 드뭅니다.

* 여러 자식 클래스(Student 등)를 하나의 부모 타입(Person)으로 다루기 위해 사용

* Student, Person 등 여러 클래스 객체를 공통 부모 타입(Person) 배열에 담을 수 있음

* 접근은 Person 수준에서만 가능 (업캐스팅 특성상)
### 다운캐스팅
* 슈퍼 크래스 레퍼런스를 서브 클래스 레퍼런스에 대입
* 업캐스팅 된 것을 다시 원래대로 되돌리는 것
* 반드시 명시적 타입 변환 지정

'''j
#public class DowncastingEx {
    public static void main(String[] args) {
        Person p = new Student("이재문");  // 업캐스팅
        Student s;

        s = (Student)p;  // 다운캐스팅

        System.out.println(s.name);  // 정상 출력
        s.grade = "A";  // 정상 접근
    }
}
'''
### 업캐스팅 레퍼런스로 객체 구별
* 업캐스팅된 레퍼런스로는 객체의 실제 타입 구분 어려움
* 슈퍼 클래스는 여러 서브 클래스에 상속되기 때문
'''j
class Person { }
class Student extends Person { }
class Researcher extends Person { }
class Professor extends Researcher { }
'''
'''j
Person p = new Person();
Person p = new Student();   // 업캐스팅
Person p = new Professor(); // 업캐스팅
'''
* 위 코드에서 p는 모두 Person 타입이지만, 실제로는 각각 다른 클래스의 인스턴스를 참조함.

* 따라서 p만 가지고는 현재 객체가 Person, Student, Professor 중 어떤 것인지 알 수 없음.

* 이런 경우 instanceof 연산자를 사용해서 실제 객체 타입을 확인할 수 있습니다
'''j
if (p instanceof Professor) {
    System.out.println("p는 Professor 객체입니다.");
} else if (p instanceof Student) {
    System.out.println("p는 Student 객체입니다.");
}
'''
### instanceof 연산자 사용
* 레퍼런스가 가리키는 객체의 타입 식별 : 연산의 결과는 true / false의 불린 값으로 반환
Person p = new Professor();
'''j
if(p instanceof Person) //ture
if(p instanceof Student) //ture
if(p instanceof Researcher) //ture
if(p instanceof Professor) //ture
if("java" instanceof String) //ture
'''
### 메소드 오버라이딩 개념
* 서브 클래스에서 슈퍼 클래스의 메소드 중복 작성
* 슈퍼 클래스의 메소드 무력화, 항상 서브 클래스에 오버라이딩한 메소드가 실행되록 보장된 / 메소드 무시하기로 번역되기도 함
* 오버라이딩 조건 - 슈퍼 클래스 메소드의 원형(메소드 이름, 인자 타입 및 개수, 리턴 타입) 동일하게 작성
### 오버라이딩 목적, 다형성 실현
* 하나의 인터페이스(같은이름)에 서로 다른 구현
* 슈퍼 클래스의 메소드를 서브 클래스에서 각각 목적에 맞게 다르게 구현
* 사례 : Shape의 draw()메소드를 Line, Rect, Circle에서 오버라이딩하여 다르게 구현
### 동적 바인딩 - 오버라이딩된 메소드 호출
* SuperObject 하나만 있는 응용프로그램의 경우 혹은 상속받은 경우 모두 동적 바인딩을 한다.
* 오버라이딩 메소드가 항상 호출된다.
* SuperObject는 키워드 X
### super 키워드로 슈퍼 클래스의 멤버 전근
* 슈퍼 클래스의 멤버를 접근할 때 사용되는 레퍼런스
* super.슈퍼클래스의멤버
* 서브 클래스에서만 사용
* 슈퍼 클래스의 필드 접근
* 슈퍼 클래스의 메소드 호출 시 super로 이루어지는 메소드 호출 : 정적 바인딩
### 오버로딩 오버라이딩


## 4월 17일 (7주차)
### this 레퍼런스
* 컴파일러에 의해 자동 관리, 개발자는 사용하기만 하면 됨
* this.멤버 형태로 멤버를 접근할 때 사용
* this()로 다른 생성자 호출
* 같은 클래스의 다른 생성자 호출
* 생성자 내에서만 사용 가능
* 생성자 코드의 제일 앞에 있어야 함
### 객체 배열
* 객체에 대한 레퍼런스 배열
* 자바의 객체배열 만들기 3단계
* 배열 레퍼런스 변수 선언
* 레퍼런스 배열 생성
* 배열의 각 원소 객체 생성
### 메소드
* 메소드는 C/C++ 함수와 동일
* 자바의 모든 메소드는 반드시 클래스 안에 있어야 함
* 접근 지정자 : 다른 클래스에서 메소드를 접근할 수 있는지 여부 선언
* public. private, protected, 디폴트 (접근 지정자생략)
* 매개 변수가 byte, int, double 등 기본 타입으로 선언되었을 때 호출자가 건네는 값이 매개 변수에 복사되어 전달. 실 인자 값은 변경되지 않음
* 인자 전달 - 배열 전달
* 배열 레퍼런스만 매개 변수에 전달 : 배열 통째로 전달되지 않음
* 객체가 전달되는 경우와 동일 : 매개 ㅂ ㅕㄴ수가 실인자의 배열 공유
### 메소드 오버로딩
* 한 클래스 내에서 두 개 이상의 이름이 같은 메소드 작성
* 메소드 이름 동일해야 함
* 매개 변수의 개수 혹은 타입이 달라야 함
* 리턴 타입은 오버로딩과 관련 없음
### 객체 치환 시 주의할 점
* 객체 치환은 객체 복사가 아니며, 레퍼런스의 복사이다.
int a = 10;          10
int b = 5;           
                      5

a = b;               5

                     5
### 객체 소멸
* new로 할당 받은 객체와 메모리를 jvm(자바가상기계)로 되돌려 주는 행위
* 자바는 객체 소멸 연산자 없음
* 객체 소멸은 jvm의 고유한 역할
* C/C++에서는 할당 받은 객체를 개발자가 프로그램 내에서 삭제해야 함
* C/C++의 프로그램 작성을 어렵게 만드는 요인
* 자바에서는 사용하지 않는 객체나 배열을 돌려주는 코딩 책임으로부터 개발자 해방
### 가비지
* 가리키는 레퍼런스가 하나도 없는 객체
* 더 이상 접근할 수 없어 사용할 수 없게 된 메모리
* 가비지 컬렉션 : 자바 가상 기계의 가비지 컬렉터가 자동으로 가비지 수집, 반환
#### 가비지 컬렉션 
* JVM이 가비지 자동 회수
* 가용 메모리 공간이 일정 이하 부족해질 때
* 가비지를 수거하여 가용 메모리 공간 확보
* 가비지 컬렉터에 의해 자동 수행
* 강제 가비지 컬렉션 강제 수행 : System 또는  Runtime 객체의 gc() 메소드 호출
System.gc(); // 가비지 컬렉션 작동 요청
* JVM에 강력한 가비지 컬렉션 요청
* 그러나 JVM이 가비지 컬렉션 시점을 전적으로 판단
### 자바의 패키지 개념
* 구별하려고 비슷비슷한 애들 모아놓음(.class 파일)
* 상호 관련 있는 클래스 파일(컴파일된 .class)를 저장하여 관리하는 디렉터리
* 자바 응용프로그램은 하나 이상의 패키지로 구성
### 접근 지정자
* 자바의 접근 지정자 4가지 : private, protected, public, 디폴트(접근 지정자 생략)
* 목적
* 클래스나 일부 멤버를 공개하여 다른 클래스에서 접근하도록 허용
* 객체 지향 언어의 캡슐화 정책은 멤버를 보호
* 접근 지정은 캡슐화에 묶인 보호를 일부 해제할 목적으로 사용
* 접근 지정자에 따른 클래스나 멤버의 공개 범위
### 클래스 접근 지정
* 다른 클래스에서 사용하도록 허용할 지 지정
* public 클래스 : 다른 모드 클래스에게 접근 허용
* 디폴트 클래스(접근 지정자 생략) : 같은 패키지의 클래스에만 접근 허용 public class World { // public 클래스}
class Local { //디폴트 클래스
}
* public 멤버 : 패키지에 관계 없이 모든 클래스에게 접근 허용
* private 멤버 : 동일 클래스 내에만 접근 허용. 상복 받은 서브 클래스에서 접근 불가
* protected 멤버 : 같은 패키지 내의 다른 모든 클래스에게 접근 허용 
상속 받은 서브 클래스는 다른 패키지에 이어도 접근 가능 
* 디폴트 멤버 : 같은 패키지 내의 다른 클래스에게 접근 허용
### static 멤버 선언
* 객체 생성과 non-static 멤버의 생성
:non static 멤버는 객체가 생설될 때, 객체마다 생긴다.
* non-static 멤버는 객체가 생성될 때마다 각각 생성되며,
### static 멤버의 생성
* static 멤버는 클래스에 하나만 존재하고 모든 객체가 공유합니다.
* 한글로 객체 영어로 인스턴스
### static 멤버 사용
* 클래스 이름으로 접근 가능
* StaticSample.m = 3; // 클래스 이름으로 static 필드 접근
* StaticSample.f(); // 클래스 이름으로 static 메소드 호출
* 객체의 멤버로 접근 가능
StaticSample b1 = new StaticSample();
b1.m = 3; // 객체 이름으로 static 필드 접근
b1.f(); // 객체 이름으로 static 메소드 호출
* non-static 멤버는 클래스 이름으로 접근 안 됨
StaticSample.n = 5; // n은 non-static 컴파일 오류
* StaticSample.g(); // g()는 non-static 컴파일 오류
* non-static 모든 객체 멤버 생성, static 멤버 공유
### static의 활용 
* 전역 변수와 전역 함수를 만들 때 할용
* 공유 멤버를 만들 때 : static으로 선언한 멤버는 클래스의 객체들 사이에 공유
* 어떤 페이지에 가든 똑같은 결과
### static 메소드의 제약 조건 1
* static 메소드는 오직 static 멤버만 접근 가능
* 객체가 생성되지 않은 상황에서도 static 메소드는 실행될 수 있기 때문에 non-static 멤버 활용 불가
* non-static 메소드는 static 멤버 사용 가능







## 4월 10일 (6주차)
## 5주차 이어서
* try-catch-(finally 생략가능)
## 4장 클래스와 객체
* ㅂㅇㅃ ㄱㄱ 클래스 ㅂㅇㅃ 객체
### 세상 모든 것이 객체다
* 객체마다 고유한 특성(변수)과 행동(함수)을 가짐
* 클래스가 가지고 있는걸 객체가 상속받아 사용
* 컴퓨터 프로그램 객체 사례 
* 테트리스 게임의 각 블록들 / 한글 프로그램의 메뉴나 버튼들
### 자바의 객체 지향 특성 : 특성화
* 캡슐화 : 객체를 캡슐로 싸서 내부를 볼 수 없게 하는 것
* 객체의 가장 본질적인 특징 / 외부 접근으로부터 객체 보호
* 자바의 캡슐화 클래스 : 객체 모양을 선언한 틀 (캡슐화하는 틀)
* 객체 : 생성된 실체(instance) : 클래스 내에 메소드와 필드 구현
### : 상속
* 상위 객체의 속성이 하위 객체에 물려 줌
* 하위 객체가 상위 객체의 속성을 모두 가지는 관계
* 실세계의 상속 사례
* 나무 = 식물의 속성 생물 속성 둘 다 가짐
* 사람 = 생물 속성O 식물 속성X
* 상위 클래스의 멤버를 하위 크래스가 물려받음
* 상위 클래스 - 수퍼 클래스
* 하위 클래스 - 서브 클래스, 수퍼 클래스 코드의 재사용, 새로운 특성 추가 가능
### 다형성 
* 같은 이름의 메소드가 클래스 혹은 객체에 따라 다르게 구현되는 것
* 다형성 사례
* 메소드 오버로딩 : 한 클래스 내에서 같은 이름이지만 다르게 작동하는 여러 메소드
* 메소드 오버라이딩 : 슈퍼 클래스의 메소드를 동일한 이름으로 서브 클래스마다 다르게 구현 
### 객체 지향 언어의 목적
#### 소프트웨어의 생산성 향상
* 컴퓨터 산업 발전에 따라 소프트웨어의 생명 주기 단축
* 소프트웨어를 빠른 속도로 생산할 필요성 증대
#### 객체 지향 언어
* 상속, 다형성, 객체, 캡슐화 등 소프트웨어 재사용을 위한 여러 장치 내장
* 소프트웨어 재사용과 부분 수정 빠름
* 소프트웨어를 다시 만드는 부담 대폭 줄임
* 소프트웨어 생산성 향상
#### 실세계에 대한 쉬운 모델링
* 초기 프로그래밍 수학 계산/통계 처리 하는 등 처리 과정, 계산 절차 중요
* 현대 프로그래밍
* 컴퓨터가 산업 전반에 활용 / 실세계에서 발생하는 일을 프로그래밍
* 실세계에서는 절차나 과정보다물체(객체)들의 상호 작용으로 묘사하는 게 용이
* 객체 지향 언어 - 실세계의 일을 쉽게 프로그래밍하기 위한 객체 중심적 언어
### 절차 지향 프로그래밍
* 작업 순서를 표현하는 컴퓨터 명령 집합 
* 함수들의 집합으로 프로그램 작성
### 객체 지향 프로그래밍
* 컴퓨터가 수행하는 작업을 객체들 간의 상호 작용으로 표현
* 클래스 혹은 객체들의 집합으로 프로그램 작성
### 클래스와 객체
* 클래스 : 객체의 속성과 행위 선언. 객체의 설계도 혹은 틀
* 객체 : 클래스의 틀로 찍어낸 실체 / 프로그램 실행 중에 생성되는 실체
* 메모리 공간을 갖는 구체적인 실체 / 인스턴스 라고도 부름
* 사례 : 클래스 : 소나타자동차 / 객체 : 출고된 실제 소나타 100대
* 클래스 : 벽시계 / 객체 : 우리집 벽에 걸린 벽시계들
* 클래스 : 책상 / 객체 : 우리가 사용중인 실제 책상들
### 클래스
* class 키워드로 선언 멤버: 클래스 구성요소 필드(변수/ 명사) 메소드(함수/ 동사)
* 클래스 public 누구나 
### 객체 생성, 활용
* 레퍼러스 변수 선언 / circle pizza;
* 객체 생성 / new 연산자 이용 pizza = new circle
* 객체 멤버 접근 / . 연산자 이용
### 생성자 개념, 목적
* 객체가 생설될 때 초기화 목적으로 실행되는 메소드
* 객체가 생성되는 순간 자동 호출
### 생성자 종류
* 매개 변수 없고, 아무 작업 없이 단순 리턴하는 생성자
* 기본 생성자가 자동 생산되는 경우
* 클래스에 생성자가 하나도 선언되어 있지 않을 때
* 컴파일러에 의해 기본 생성자 자동 생성
* class Circle {
    public Circle() {} // 기본 생성자
}



## 4월 3일 (5주차)
## for 문
* 횟수 정해지면 사용

### while 문(조건식)
* 조건식이 참인 동안 반복 실행
* for - 횟수 정해지면 for(구구단)
* while - 횟수 정해지지 않을 때 사용
* (반복 되는데 횟수 안 정해진 거) 
### do while 문 
* 조건식이 참인 동안 반복 실행 작업문은 한 번 반드시 실행
### 중첩 반복
* 반복문이 다른 반복문을 내포하는 구조 for 문을 이용한 이중 중첩 구조
### countinue 문
* 반복문을 빠져 나가지 않고 다음 반복으로 제어 변경
### break 문
* 반복문 하나를 즉시 벗어날 때 사용. 하나의 반복문만 벗어남
* 중첩 반복의 경우 안쪽 반복문의 break 문이 실행되면 안쪽 반복문만 벗어남
### 자바 배열(array)
* 인덱스와 인덱스와 대응하는 데이터들로 이루어진 자료 구조로한 번에 많은 메모리 공간 선언
* 같은 타입의 데이터들이 순차적으로 저장되는 공간으로 인덱스를 이용하여 원소 데이터 접근
* 반복문을 이용하여 처리하기에 적합한 자료 구조
* 배열 선언, 생성
int(배열타입) intArrary(배열에 대한 래퍼런스 변수) [];(배열 선언)
* 생성 intArray(배열에 대한 레퍼런스 변수) = new(배열 생성) int (타입) [5];(원소 개수)
* 배열 선언 및 생성 디테일 - 배열은 선언과 생성의 두 단계 필요 : 선언 동시 생성O
* 배열 선언 - 배열의 이름 선언(배열 레퍼런스 변수 선언)
* 생성 - 배열 공간 할당 받는 과정
* 배열 초기화 - 배열 생성과 값 초기화
* 배열 인덱스 - 0부터, 크기 1부터 - 음수X 
* intArray = new int [5]; -(0 1 2 3 4 )
* intArray = new int [6]; -(0 1 2 3 4 5)
* 자바 배열 - 객체 처리 배열 크기는 배열 객체 length 필드에 저장
* for(int i=0; i<intArray.lenght; i++) - intArray 배열 크기만큼 루프 돈다
### for-each 문
* 배열이나 나열의 원소를 순차 접근하는데 유용한 for 문
### 2차원 배열
* int intArray[2][5]; or int[2][5] intArray
* 2차원 배열 length 필드
* i. length - 2차원 배열의 행의 개수 - 2
* i[n].length - n번째 행의 열의 개수
* i[1].length - 1번째 행의 열의 개수 - 5 
### 메소드의 배열 리턴
* 배열의 레퍼런스만 리턴, 전체 리턴X
* 메소드의 리턴타입 - 리턴하는 배열 타입과 리턴 받는 배열 타입 일치 -리턴 타입에 배열의 크기 지정X
### 자바의 예외 처리, try-catch 문
* 예외 처리 : 2발생한 예외에 대해 개발자가 작성한 프로그램 코드에서 대응하는 것
* finally 블록은 생략 가능





## 3월 27일(4주차)
 * 소스 코드 - 우리가 사용하는 java코드(foo.txt .java)
 * 바이트코드 .class 파일 javac 소드코드 변환한 중간 코드 cpu 실행X JVM 실행해야함
 어셈블리어
 * 기계어 CPU 실행O 0,1 이진 코드 - 운영체재와 CPU 아키텍처 등에 따라 다름 16진수 형태 기계어
 * 식별자 - 클래스, 변수, 상수, 메소드 등에 붙이는 이름 _ $ 가능 유니코드 문자 가능 대소문자 구별
 * Java 데이터 타입 기본자료형 8개있음 논리 문자 정수 실수 타입 문자열 String 클래스로 표현 # 리터널 - 소스 코드 중 특정한 자료형의 값
 * 참조 자료형 = 주소를 저장 할 수 없음 - 주소 없지만 JVM이 주소로 안내 객체를 참조하는 변수 유형 - 힙(Heap)영역에 저장된 객체 메모리 주소 가르킴 
 기본 자료형 - 스택(Stack)저장
 New 키워드 객체(인스턴스)생성 -참조 자료형 선언 -JVM이 객체 주소 저장
 * 메모리 안정성, 가비지 컬렉션 지원, 코드의 단순화, 및 가독성 향상, 보안 강화, 다중 플랫폼 지원
 * 메모리의 구조 힙 heap fifo(first in first out) 프로그래머가 직접 공간 할당 해제하는 메모리 공간
 java-jvm 담당
 스택 stack lifo() 프로그램이 자동 사용 임시메모리
 힙-스택 침범 힙 오버플로우 스택 힙 침범 스택 오버플로우
 * 변수 선언 값 임시 저장 
 int(데이터) price(변수)
상수 final 키워드 사용
final(상수선언) int(데이터타입) PI(상수이름) == 3.141592(초기화)
* var 타입 생략 변수 선언
* 증감연산자 많이써요
### 자바 버추얼 머신, 멀티스레딩 이해
멀티스레딩은 프로그램이 여러개 실행될 때 동시에 수행하도록 하는 기술
멀티스레딩은 운영체제 도움 받지 않음

### 감지 컬렉션, 메모리 변환
감지컬렉션 = 사용하지 않는 메모리를 자동으로 정리하는 기능 = 반환 명령없이 메모리를 잡아먹지 않도록 함
메모리 변환 = 잠심 멈춤으로써 이뤄지면 실시간 응용 프로그램에 부적합



'''c
public class Ex3DoWhile {
    public static void main (String[] args) {
        char a = 'a'; 

        do {
            System.out.print(a);
            a = (char) (a + 1);
        } while (a <= 'z');
    }    
}
'''
#### README.md 파일 편집

* 이름 학번 h1 제일 위에 기재

* 날짜(주차)

* 배운내용&코드

* 최근 날짜가 제일 위로 올라오게


# h1 tag
## h2
### h3
#### h4
##### h5 
###### h6



---

* ㅣㅏㅏㅏㅏ
- ㅓㅓㅓㅓㅓㅓ


1. 이이이이이1
2. 주주주주주2
5. 영영영영영3
